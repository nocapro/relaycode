uuid: 1d63659c-ac3e-4638-b710-186ed0282b04
projectId: relaycode
createdAt: '2025-09-03T14:00:05.887Z'
linesAdded: 37
linesRemoved: 1
gitCommitMsg: 'feat(parser): add debug logging to trace content processing'
promptSummary: >-
  User requested the previous response (1d63659c) be resent using the
  multi-search-replace strategy.
reasoning:
  - >-
    aight, you got it. resending the last set of changes, but using
    `multi-search-replace` as requested. this will create the new logger file,
    then surgically inject the new import and debug statements into the parser.
    same result, different method.
  - first, here's the new logger file.
  - next, exporting the logger from the package index.
  - and finally, instrumenting the parser with debug logs.
operations:
  - type: write
    path: packages/relaycode-core/src/logger.ts
    content: |-
      // A simple logger for debugging within the core package.
      // To enable debug logs, set LOG_LEVEL=debug in the environment.
      const LOG_LEVEL = process.env.LOG_LEVEL || 'info';

      const levels: { [key: string]: number } = {
        debug: 0,
        info: 1,
        warn: 2,
        error: 3,
      };

      const currentLevel = levels[LOG_LEVEL] ?? 1;

      const log = (level: number, prefix: string, ...args: any[]) => {
        if (level >= currentLevel) {
          if (level === levels.debug) {
              console.log(`\x1b[90m${prefix}\x1b[0m`, ...args); // Gray for debug
          } else {
              console.log(prefix, ...args);
          }
        }
      };

      export const logger = {
        debug: (...args: any[]) => log(levels.debug, '[DEBUG]', ...args),
        info: (...args: any[]) => log(levels.info, '[INFO]', ...args),
        warn: (...args: any[]) => log(levels.warn, '[WARN]', ...args),
        error: (...args: any[]) => log(levels.error, '[ERROR]', ...args),
      };
    patchStrategy: replace
  - type: write
    path: packages/relaycode-core/src/index.ts
    content: |-
      <<<<<<< SEARCH
      export * from './patch';
      =======
      export * from './patch';
      export * from './logger';
      >>>>>>> REPLACE
    patchStrategy: multi-search-replace
  - type: write
    path: packages/relaycode-core/src/parser.ts
    content: |-
      <<<<<<< SEARCH
      import yaml from 'js-yaml';
      =======
      import yaml from 'js-yaml';
      import { logger } from './logger';
      >>>>>>> REPLACE
      <<<<<<< SEARCH
          const [fullMatch, rawHeader, rawContent] = match;
          let headerLine = (rawHeader || '').trim();
          // The regex is non-greedy and will match until the first ``` it sees.
          // This often captures a trailing newline before the fence that isn't part of the content.
          const content = (rawContent || '').replace(/\r?\n$/, '');

          const commentIndex = headerLine.indexOf('//');
      =======
          const [fullMatch, rawHeader, rawContent] = match;
          let headerLine = (rawHeader || '').trim();
          // The regex is non-greedy and will match until the first ``` it sees.
          // This often captures a trailing newline before the fence that isn't part of the content.
          const content = (rawContent || '').replace(/\r?\n$/, '');
          
          logger.debug(`[parser] Matched block header: '${rawHeader}'`);
          logger.debug(`[parser] Raw content (JSON encoded):`, JSON.stringify(rawContent));
          logger.debug(`[parser] Content after trailing newline strip (JSON encoded):`, JSON.stringify(content));
          
          const commentIndex = headerLine.indexOf('//');
      >>>>>>> REPLACE
      <<<<<<< SEARCH
              if (startMarkerIndex !== -1 && endMarkerIndex !== -1 && endMarkerIndex > startMarkerIndex) {
                  const relevantContent = content.substring(startMarkerIndex + CODE_BLOCK_START_MARKER.length, endMarkerIndex);
                  cleanContent = relevantContent.replace(/^\r?\n/, '').replace(/\r?\n\s*$/, '');
              } else {
                  cleanContent = content.replace(/^\r?\n/, '');
              }
          }
      =======
              if (startMarkerIndex !== -1 && endMarkerIndex !== -1 && endMarkerIndex > startMarkerIndex) {
                  const relevantContent = content.substring(startMarkerIndex + CODE_BLOCK_START_MARKER.length, endMarkerIndex);
                  cleanContent = relevantContent.replace(/^\r?\n/, '').replace(/\r?\n\s*$/, '');
              } else {
                  cleanContent = content.replace(/^\r?\n/, '');
              }
              logger.debug(`[parser] Final 'replace' content (JSON encoded):`, JSON.stringify(cleanContent));
          }
      >>>>>>> REPLACE
    patchStrategy: multi-search-replace
snapshot:
  packages/relaycode-core/src/logger.ts: null
  packages/relaycode-core/src/index.ts: |-
    export * from './types';
    export * from './constants';
    export * from './parser';
    export * from './patch';
  packages/relaycode-core/src/parser.ts: >-
    import yaml from 'js-yaml';

    import { z } from 'zod';

    import {
        ControlYamlSchema,
        FileOperation,
        ParsedLLMResponse,
        ParsedLLMResponseSchema,
        PatchStrategy,
        PatchStrategySchema,
    } from './types';

    import {
        CODE_BLOCK_START_MARKER,
        CODE_BLOCK_END_MARKER,
        DELETE_FILE_MARKER,
        RENAME_FILE_OPERATION
    } from './constants';


    const CODE_BLOCK_REGEX = /```(?:\w+)?\s*([^\r\n]*?)\r?\n([\s\S]*?)```/g;


    const mapStrategyAlias = (strategy: string): string => {
        if (strategy === 'new-unified') return 'standard-diff';
        if (strategy === 'multi-search-replace') return 'search-replace';
        return strategy;
    };


    type ParsedHeader = {
        filePath: string;
        patchStrategy: PatchStrategy | null;
    };


    const parseCodeBlockHeader = (headerLine: string): ParsedHeader | null => {
        // This regex handles:
        // 1. A quoted file path, optionally followed by a strategy.
        // 2. An unquoted file path, optionally followed by a strategy.
        // It's more robust than splitting by space.
        const match = headerLine.match(/^(?:"([^"]+)"|(\S+))(?:\s+(\S+))?$/);
        
        if (!match) {
            // If the regex fails, it might be a path with spaces that isn't quoted.
            // The instructions say paths with spaces MUST be quoted, but we can be lenient.
            // We'll check if the last word is a strategy. If so, the rest is the path.
            const parts = headerLine.split(/\s+/);
            if (parts.length > 1) {
                const lastPart = parts[parts.length - 1]!;
                const mappedStrategy = mapStrategyAlias(lastPart);
                const parsedStrategy = PatchStrategySchema.safeParse(mappedStrategy);
                if (parsedStrategy.success) {
                    const filePath = parts.slice(0, -1).join(' ');
                    return { filePath, patchStrategy: parsedStrategy.data };
                }
            }
            // Otherwise, assume the whole line is a file path with no strategy.
            return headerLine.trim() ? { filePath: headerLine.trim(), patchStrategy: null } : null;
        }

        const filePath = match[1] || match[2]; // Group 1 is quoted, group 2 is unquoted.
        if (!filePath) return null;

        const strategyStr = match[3] || '';
        const mappedStrategy = mapStrategyAlias(strategyStr);
        const parsedStrategy = PatchStrategySchema.safeParse(mappedStrategy);

        return { filePath, patchStrategy: parsedStrategy.success ? parsedStrategy.data : null };
    };


    const inferPatchStrategy = (content: string, providedStrategy: PatchStrategy
    | null): PatchStrategy => {
        if (providedStrategy) return providedStrategy;
        if (/^<<<<<<< SEARCH\s*$/m.test(content) && content.includes('>>>>>>> REPLACE')) return 'search-replace';
        if (content.startsWith('--- ') && content.includes('+++ ') && content.includes('@@')) return 'standard-diff';
        return 'replace';
    };


    const extractAndParseYaml = (rawText: string) => {
        // Strategy 1: Find all fenced YAML blocks and try to parse the last one.
        const yamlBlockMatches = [...rawText.matchAll(/```\s*(?:yaml|yml)[\r\n]([\s\S]+?)```/gi)];

        if (yamlBlockMatches.length > 0) {
            const lastMatch = yamlBlockMatches[yamlBlockMatches.length - 1]!;
            try {
                const yamlContent: unknown = yaml.load(lastMatch[1]!);
                const control = ControlYamlSchema.parse(yamlContent);
                // Success! This is our control block.
                const textWithoutYaml = rawText.substring(0, lastMatch.index) + rawText.substring(lastMatch.index! + lastMatch[0].length);
                return { control, textWithoutYaml: textWithoutYaml.trim() };
            } catch (e) {
                // The last block was not a valid control block.
                // We will now fall through to the non-fenced strategy, assuming the fenced block was just an example.
            }
        }

        // Strategy 2: Look for a non-fenced block at the end.
        const lines = rawText.trim().split('\n');
        let yamlStartIndex = -1;
        // Heuristic: project ID is required, so we look for that.
        const searchLimit = Math.max(0, lines.length - 20);
        for (let i = lines.length - 1; i >= searchLimit; i--) {
            if (lines[i]?.trim().match(/^projectId:/)) {
                yamlStartIndex = i;
                break;
            }
        }

        if (yamlStartIndex !== -1) {
            const yamlText = lines.slice(yamlStartIndex).join('\n');
            try {
                const yamlContent: unknown = yaml.load(yamlText);
                const control = ControlYamlSchema.parse(yamlContent);
                // Success!
                const textWithoutYaml = lines.slice(0, yamlStartIndex).join('\n');
                return { control, textWithoutYaml: textWithoutYaml.trim() };
            } catch (e) {
                // Non-fenced YAML block at the end was not a valid control block.
            }
        }
        
        // If both strategies fail, there's no valid control block.
        return { control: null, textWithoutYaml: rawText };
    };


    const parseCodeBlock = (match: RegExpExecArray): { operation: FileOperation,
    fullMatch: string } | null => {
        const [fullMatch, rawHeader, rawContent] = match;
        let headerLine = (rawHeader || '').trim();
        // The regex is non-greedy and will match until the first ``` it sees.
        // This often captures a trailing newline before the fence that isn't part of the content.
        const content = (rawContent || '').replace(/\r?\n$/, '');

        const commentIndex = headerLine.indexOf('//');
        if (commentIndex !== -1) {
            // If we find `//`, we assume what follows is the file path and optional strategy.
            // This handles `typescript // "path/to/my component.ts" new-unified`.
            headerLine = headerLine.substring(commentIndex + 2).trim();
        }

        if (headerLine.startsWith('//')) {
            headerLine = headerLine.substring(2).trim();
        }

        if (!headerLine) return null;

        if (headerLine === RENAME_FILE_OPERATION) {
            try {
                const { from, to } = z.object({ from: z.string().min(1), to: z.string().min(1) }).parse(JSON.parse(content));
                return { operation: { type: 'rename', from, to }, fullMatch };
            } catch (e) {
                return null;
            }
        }

        const parsedHeader = parseCodeBlockHeader(headerLine);
        if (!parsedHeader) {
            return null;
        }

        const { filePath } = parsedHeader;

        if (content.trim() === DELETE_FILE_MARKER) {
            return { operation: { type: 'delete', path: filePath }, fullMatch };
        }

        const patchStrategy = inferPatchStrategy(content, parsedHeader.patchStrategy);

        let cleanContent = content;
        if (patchStrategy === 'replace') {
            const startMarkerIndex = content.indexOf(CODE_BLOCK_START_MARKER);
            const endMarkerIndex = content.lastIndexOf(CODE_BLOCK_END_MARKER);

            if (startMarkerIndex !== -1 && endMarkerIndex !== -1 && endMarkerIndex > startMarkerIndex) {
                const relevantContent = content.substring(startMarkerIndex + CODE_BLOCK_START_MARKER.length, endMarkerIndex);
                cleanContent = relevantContent.replace(/^\r?\n/, '').replace(/\r?\n\s*$/, '');
            } else {
                cleanContent = content.replace(/^\r?\n/, '');
            }
        }

        return {
            operation: { type: 'write', path: filePath, content: cleanContent, patchStrategy },
            fullMatch
        };
    };


    export const parseLLMResponse = (rawText: string): ParsedLLMResponse | null
    => {
        const { control, textWithoutYaml } = extractAndParseYaml(rawText);

        if (!control) {
            return null;
        }

        const operations: FileOperation[] = [];
        const matchedBlocks: string[] = [];
        let match;

        while ((match = CODE_BLOCK_REGEX.exec(textWithoutYaml)) !== null) {
            const result = parseCodeBlock(match);
            if (result) {
                operations.push(result.operation);
                matchedBlocks.push(result.fullMatch);
            }
        }

        if (operations.length === 0) {
            return null;
        }

        let reasoningText = textWithoutYaml;
        for (const block of matchedBlocks) {
            reasoningText = reasoningText.replace(block, '');
        }
        const reasoning = reasoningText.split('\n').map(line => line.trim()).filter(Boolean);

        try {
            const parsedResponse = ParsedLLMResponseSchema.parse({ control, operations, reasoning });
            return parsedResponse;
        } catch (e) {
            return null;
        }
    };
approved: true
