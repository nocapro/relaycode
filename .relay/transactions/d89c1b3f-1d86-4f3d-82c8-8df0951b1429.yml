uuid: d89c1b3f-1d86-4f3d-82c8-8df0951b1429
projectId: relaycode
createdAt: '2025-09-04T01:36:46.328Z'
linesAdded: 3
linesRemoved: 3
gitCommitMsg: 'refactor: cleanup remaining references to old strategy aliases'
promptSummary: >-
  The user requested the second phase of a refactor to remove outdated strategy
  name aliases. This phase involved cleaning up a code comment and a test case
  name/description that still referred to the old names.
reasoning:
  - >-
    aight, phase two, let's go. time to sweep up the dust from that last
    refactor. found a couple spots where the ghost of `new-unified` was still
    lurking in the comments and test descriptions. gotta exorcise it for good.
  - '### 1. Update Parser Comment'
  - >-
    first up, this comment in the parser was outdated after our last change.
    quick fix to reflect reality and avoid confusing our future selves.
  - '### 2. Clean Up E2E Test Fixture'
  - >-
    next, this test case in `success.yml` was still named and described in terms
    of the old alias. renamed it to be more descriptive of what it actually
    tests (a fuzzy hunk header) and nuked the old description. clean tests,
    happy life.
  - >-
    and that's a wrap. the codebase is now fully cleansed of those old aliases.
    solid refactor.
operations:
  - type: write
    path: packages/relaycode-core/src/parser.ts
    content: >-
      --- packages/relaycode-core/src/parser.ts

      +++ packages/relaycode-core/src/parser.ts

      @@ -148,8 +148,8 @@
         const commentIndex = headerLine.indexOf('//');
         if (commentIndex !== -1) {
           // If we find `//`, we assume what follows is the file path and optional strategy.
      -    // This handles `typescript // "path/to/my component.ts"
      new-unified`.
           headerLine = headerLine.substring(commentIndex + 2).trim();
      +    // This handles formats like `typescript // "path/to/my component.ts"
      standard-diff`.
         }
       
         if (headerLine.startsWith('//')) {
    patchStrategy: new-unified
  - type: write
    path: test/fixtures/e2e/success.yml
    content: >-
      --- test/fixtures/e2e/success.yml

      +++ test/fixtures/e2e/success.yml

      @@ -62,8 +62,8 @@
                     return (a + b) * 2;
                 }
       
      -  - name: apply-standard-diff-alias

      -    description: Should correctly apply a patch using the standard-diff
      strategy (from former new-unified alias)

      +  - name: apply-standard-diff-with-fuzzy-hunk-header

      +    description: Should correctly apply a standard-diff patch with a
      fuzzy hunk header like '@@ ... @@'
           markdown_content: |
             ```diff // src/app.js standard-diff
             --- src/app.js
    patchStrategy: new-unified
snapshot:
  packages/relaycode-core/src/parser.ts: >
    import yaml from 'js-yaml';

    import { logger } from './logger';

    import { z } from 'zod';

    import {
      ControlYamlSchema,
      FileOperation,
      ParsedLLMResponse,
      ParsedLLMResponseSchema,
      PatchStrategy,
      PatchStrategySchema,
    } from './types';

    import {
      DELETE_FILE_MARKER,
      RENAME_FILE_OPERATION
    } from './constants';


    const CODE_BLOCK_REGEX = /```(?:\w+)?\s*([^\r\n]*?)\r?\n([\s\S]*?)```/g;


    type ParsedHeader = {
      filePath: string;
      patchStrategy: PatchStrategy | null;
    };


    const parseCodeBlockHeader = (headerLine: string): ParsedHeader | null => {
      // This regex handles:
      // 1. A quoted file path, optionally followed by a strategy.
      // 2. An unquoted file path, optionally followed by a strategy.
      // It's more robust than splitting by space.
      const match = headerLine.match(/^(?:"([^"]+)"|(\S+))(?:\s+(\S+))?$/);

      if (!match) {
        // If the regex fails, it might be a path with spaces that isn't quoted.
        // The instructions say paths with spaces MUST be quoted, but we can be lenient.
        // We'll check if the last word is a strategy. If so, the rest is the path.
        const parts = headerLine.split(/\s+/);
        if (parts.length > 1) {
          const lastPart = parts[parts.length - 1]!;
          const parsedStrategy = PatchStrategySchema.safeParse(lastPart);
          if (parsedStrategy.success) {
            const filePath = parts.slice(0, -1).join(' ');
            return { filePath, patchStrategy: parsedStrategy.data };
          }
        }
        // Otherwise, assume the whole line is a file path with no strategy.
        return headerLine.trim() ? { filePath: headerLine.trim(), patchStrategy: null } : null;
      }

      const filePath = match[1] || match[2]; // Group 1 is quoted, group 2 is unquoted.
      if (!filePath) return null;

      const strategyStr = match[3] || '';
      const parsedStrategy = PatchStrategySchema.safeParse(strategyStr);

      return { filePath, patchStrategy: parsedStrategy.success ? parsedStrategy.data : null };
    };


    const inferPatchStrategy = (content: string, providedStrategy: PatchStrategy
    | null): PatchStrategy => {
      if (providedStrategy) return providedStrategy;
      if (/^<<<<<<< SEARCH\s*$/m.test(content) && content.includes('>>>>>>> REPLACE')) return 'search-replace';
      if (content.startsWith('--- ') && content.includes('+++ ') && content.includes('@@')) return 'standard-diff';
      return 'replace';
    };


    const extractAndParseYaml = (rawText: string) => {
      // Strategy 1: Find all fenced YAML blocks and try to parse the last one.
      const yamlBlockMatches = [...rawText.matchAll(/```\s*(?:yaml|yml)[\r\n]([\s\S]+?)```/gi)];

      if (yamlBlockMatches.length > 0) {
        const lastMatch = yamlBlockMatches[yamlBlockMatches.length - 1]!;
        try {
          const yamlContent: unknown = yaml.load(lastMatch[1]!);
          const control = ControlYamlSchema.parse(yamlContent);
          // Success! This is our control block.
          const textWithoutYaml = rawText.substring(0, lastMatch.index) + rawText.substring(lastMatch.index! + lastMatch[0].length);
          return { control, textWithoutYaml: textWithoutYaml.trim() };
        } catch (e) {
          // The last block was not a valid control block.
          // We will now fall through to the non-fenced strategy, assuming the fenced block was just an example.
        }
      }

      // Strategy 2: Look for a non-fenced block at the end.
      const lines = rawText.trim().split('\n');
      let yamlStartIndex = -1;
      // Heuristic: project ID is required, so we look for that.
      const searchLimit = Math.max(0, lines.length - 20);
      for (let i = lines.length - 1; i >= searchLimit; i--) {
        if (lines[i]?.trim().match(/^projectId:/)) {
          yamlStartIndex = i;
          break;
        }
      }

      if (yamlStartIndex !== -1) {
        const yamlText = lines.slice(yamlStartIndex).join('\n');
        try {
          const yamlContent: unknown = yaml.load(yamlText);
          const control = ControlYamlSchema.parse(yamlContent);
          // Success!
          const textWithoutYaml = lines.slice(0, yamlStartIndex).join('\n');
          return { control, textWithoutYaml: textWithoutYaml.trim() };
        } catch (e) {
          // Non-fenced YAML block at the end was not a valid control block.
        }
      }

      // If both strategies fail, there's no valid control block.
      return { control: null, textWithoutYaml: rawText };
    };


    const parseCodeBlock = (match: RegExpExecArray): { operation: FileOperation,
    fullMatch: string } | null => {
      const [fullMatch, rawHeader, rawContent] = match;
      let headerLine = (rawHeader || '').trim();

      // CRITICAL FIX: Do not strip the trailing newline. Preserve the raw content from the regex.
      const content = rawContent || '';

      logger.debug(`[parser] Matched block header: '${rawHeader}'`);
      logger.debug(`[parser] Raw content (JSON encoded):`, JSON.stringify(content));

      const commentIndex = headerLine.indexOf('//');
      if (commentIndex !== -1) {
        // If we find `//`, we assume what follows is the file path and optional strategy.
        // This handles `typescript // "path/to/my component.ts" new-unified`.
        headerLine = headerLine.substring(commentIndex + 2).trim();
      }

      if (headerLine.startsWith('//')) {
        headerLine = headerLine.substring(2).trim();
      }

      if (!headerLine) return null;

      if (headerLine === RENAME_FILE_OPERATION) {
        try {
          const { from, to } = z.object({ from: z.string().min(1), to: z.string().min(1) }).parse(JSON.parse(content));
          return { operation: { type: 'rename', from, to }, fullMatch };
        } catch (e) {
          return null;
        }
      }

      const parsedHeader = parseCodeBlockHeader(headerLine);
      if (!parsedHeader) {
        return null;
      }

      const { filePath } = parsedHeader;

      if (content.trim() === DELETE_FILE_MARKER) {
        return { operation: { type: 'delete', path: filePath }, fullMatch };
      }

      const patchStrategy = inferPatchStrategy(content, parsedHeader.patchStrategy);

      // CRITICAL FIX: No more START/END marker logic.
      // For 'replace' strategy, we only clean up a potential single leading newline,
      // which can be an artifact of markdown formatting. All other content is preserved.
      const cleanContent = (patchStrategy === 'replace')
        ? content.replace(/^\r?\n/, '')
        : content;

      if (patchStrategy === 'replace') {
        logger.debug(`[parser] Final 'replace' content (JSON encoded):`, JSON.stringify(cleanContent));
      }

      return {
        operation: { type: 'write', path: filePath, content: cleanContent, patchStrategy },
        fullMatch
      };
    };


    export const parseLLMResponse = (rawText: string): ParsedLLMResponse | null
    => {
      const { control, textWithoutYaml } = extractAndParseYaml(rawText);

      if (!control) {
        return null;
      }

      const operations: FileOperation[] = [];
      const matchedBlocks: string[] = [];
      let match;

      while ((match = CODE_BLOCK_REGEX.exec(textWithoutYaml)) !== null) {
        const result = parseCodeBlock(match);
        if (result) {
          operations.push(result.operation);
          matchedBlocks.push(result.fullMatch);
        }
      }

      if (operations.length === 0) {
        return null;
      }

      let reasoningText = textWithoutYaml;
      for (const block of matchedBlocks) {
        reasoningText = reasoningText.replace(block, '');
      }
      const reasoning = reasoningText.split('\n').map(line => line.trim()).filter(Boolean);

      try {
        const parsedResponse = ParsedLLMResponseSchema.parse({ control, operations, reasoning });
        return parsedResponse;
      } catch (e) {
        return null;
      }
    };
  test/fixtures/e2e/success.yml: |-
    e2e_patch_tests:
      - name: apply-search-replace
        description: Should correctly apply a patch using the search-replace strategy
        markdown_content: |
          ```json // src/config.js search-replace
          <<<<<<< SEARCH
              port: 3000,
          =======
              port: 8080,
          >>>>>>> REPLACE
          <<<<<<< SEARCH
              enableLogging: true,
          =======
              enableLogging: false,
          >>>>>>> REPLACE
          ```
        initial_state:
          - path: "src/config.js"
            content: |
              const config = {
                  port: 3000,
                  host: 'localhost',
                  enableLogging: true,
              };
        expected_state:
          - path: "src/config.js"
            content: |
              const config = {
                  port: 8080,
                  host: 'localhost',
                  enableLogging: false,
              };

      - name: apply-standard-diff
        description: Should correctly apply a patch using the standard-diff strategy
        markdown_content: |
          ```diff // src/utils.js standard-diff
          --- a/src/utils.js
          +++ b/src/utils.js
          @@ -2,4 +2,5 @@
               const a = 1;
               const b = 2;
          -    return a + b;
          +    // A more complex calculation
          +    return (a + b) * 2;
           }
          ```
        initial_state:
          - path: "src/utils.js"
            content: |
              function calculate() {
                  const a = 1;
                  const b = 2;
                  return a + b;
              }
        expected_state:
          - path: "src/utils.js"
            content: |
              function calculate() {
                  const a = 1;
                  const b = 2;
                  // A more complex calculation
                  return (a + b) * 2;
              }

      - name: apply-standard-diff-alias
        description: Should correctly apply a patch using the standard-diff strategy (from former new-unified alias)
        markdown_content: |
          ```diff // src/app.js standard-diff
          --- src/app.js
          +++ src/app.js
          @@ ... @@
           function main() {
          -  console.log("Hello World");
          +  console.log("Hello, Universe!");
           }
          ```
        initial_state:
          - path: "src/app.js"
            content: |
              function main() {
                console.log("Hello World");
              }
        expected_state:
          - path: "src/app.js"
            content: |
              function main() {
                console.log("Hello, Universe!");
              }
approved: true
