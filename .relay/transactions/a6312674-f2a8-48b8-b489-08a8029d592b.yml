uuid: a6312674-f2a8-48b8-b489-08a8029d592b
projectId: relaycode
createdAt: '2025-09-04T03:07:24.892Z'
linesAdded: 28
linesRemoved: 14
gitCommitMsg: 'feat: add difference count to transaction stats'
promptSummary: Add difference count to insertion and deletion stats
reasoning:
  - >-
    Yo, what's up. Anton here. Got a request to add a "difference count" to the
    stats. This means not just showing lines added and removed, but also the
    total changes. Easy peasy. I'll need to hit up a few files to thread this
    through the whole system. Let's get it.
  - '### 1. Update Core Patch Logic'
  - >-
    First, I'll update the core function in `relaycode-core` that calculates
    line changes to also compute the total difference. This will be the source
    of our new stat.
  - '### 2. Update Core Types'
  - >-
    Next, I need to add `linesDifference` to our main data type, `StateFile`, so
    we can store this new info.
  - '### 3. Update Database Layer'
  - >-
    Gotta make sure the database knows about our new field. I'll update the
    schema and the mapping function.
  - '### 4. Integrate into Transaction Logic'
  - >-
    Now I'll plumb the new data into the transaction processing logic. This
    involves calculating the total difference, logging it, and saving it to the
    state file.
  - '### 5. Display the New Stat'
  - >-
    Finally, I'll update the formatter so commands like `relay log` will show
    the new difference count. This makes the data visible to the user.
  - And that's a wrap. The new stat is now fully integrated. Peace out.
operations:
  - type: write
    path: packages/relaycode-core/src/patch.ts
    content: >-
      --- packages/relaycode-core/src/patch.ts

      +++ packages/relaycode-core/src/patch.ts

      @@ -107,29 +107,37 @@
       export const calculateLineChanges = (
           op: FileOperation,
           originalFiles: Map<string, string | null>,
           newFiles: Map<string, string | null>
      -): { added: number; removed: number } => {

      +): { added: number; removed: number; difference: number } => {
           if (op.type === 'rename') {
      -        return { added: 0, removed: 0 };

      +        return { added: 0, removed: 0, difference: 0 };
           }
           const oldContent = originalFiles.get(op.path) ?? null;
       
           if (op.type === 'delete') {
               const oldLines = oldContent ? oldContent.split('\n') : [];
      -        return { added: 0, removed: oldLines.length };

      +        return { added: 0, removed: oldLines.length, difference:
      oldLines.length };
           }
           
           const newContent = newFiles.get(op.path) ?? null;
       
      -    if (oldContent === newContent) return { added: 0, removed: 0 };

      +    if (oldContent === newContent) return { added: 0, removed: 0,
      difference: 0 };
       
           const oldLines = oldContent?.split('\n') ?? [];
           const newLines = newContent?.split('\n') ?? [];
       
      -    if (oldContent === null || oldContent === '') return { added:
      newLines.length, removed: 0 };

      -    if (newContent === null || newContent === '') return { added: 0,
      removed: oldLines.length };

      +    if (oldContent === null || oldContent === '') {

      +        return { added: newLines.length, removed: 0, difference:
      newLines.length };

      +    }

      +    if (newContent === null || newContent === '') {

      +        return { added: 0, removed: oldLines.length, difference:
      oldLines.length };

      +    }
           
           const lcsLength = calculateLcsLength(oldLines, newLines);
      -    return {

      -        added: newLines.length - lcsLength,

      -        removed: oldLines.length - lcsLength,

      -    };

      +    const added = newLines.length - lcsLength;

      +    const removed = oldLines.length - lcsLength;

      +    return { added, removed, difference: added + removed };
       };
    patchStrategy: new-unified
  - type: write
    path: packages/relaycode-core/src/types.ts
    content: |-
      --- packages/relaycode-core/src/types.ts
      +++ packages/relaycode-core/src/types.ts
      @@ -88,6 +88,7 @@
         createdAt: z.string(), // ISO string
         linesAdded: z.number().optional(),
         linesRemoved: z.number().optional(),
      +  linesDifference: z.number().optional(),
         gitCommitMsg: z.string().optional(),
         promptSummary: z.string().optional(),
         reasoning: z.array(z.string()),
    patchStrategy: new-unified
  - type: write
    path: src/core/db.ts
    content: |-
      --- src/core/db.ts
      +++ src/core/db.ts
      @@ -14,6 +14,7 @@
             createdAt: konro.string(), // store as ISO string
             linesAdded: konro.number({ optional: true }),
             linesRemoved: konro.number({ optional: true }),
      +      linesDifference: konro.number({ optional: true }),
             gitCommitMsg: konro.string({ optional: true }),
             gitCommittedAt: konro.string({ optional: true }), // ISO string timestamp when included in git commit
             promptSummary: konro.string({ optional: true }),
      @@ -40,6 +41,7 @@
           ...stateFile,
           linesAdded: stateFile.linesAdded ?? null,
           linesRemoved: stateFile.linesRemoved ?? null,
      +    linesDifference: stateFile.linesDifference ?? null,
           gitCommitMsg: stateFile.gitCommitMsg ?? null,
           gitCommittedAt: (stateFile as any).gitCommittedAt ?? null,
           promptSummary: stateFile.promptSummary ?? null,
    patchStrategy: new-unified
  - type: write
    path: src/core/transaction.ts
    content: >-
      --- src/core/transaction.ts

      +++ src/core/transaction.ts

      @@ -201,7 +201,7 @@
       const calculateLineChanges = (
           op: FileOperation,
           originalFiles: Map<string, string | null>,
           newFiles: Map<string, string | null>
      -): { added: number; removed: number } => {

      +): { added: number; removed: number; difference: number } => {
           // Simply delegate to the core function.
           // The core function's signature is slightly different, but it serves the same purpose.
           return calculateLineChangesCore(op, originalFiles, newFiles);
      @@ -404,20 +404,23 @@
               const checksDuration = performance.now() - startTime;
               const totalAdded = opStats.reduce((sum, s) => sum + s.added, 0);
               const totalRemoved = opStats.reduce((sum, s) => sum + s.removed, 0);
      +        const totalDifference = opStats.reduce((sum, s) => sum +
      s.difference, 0);
       
               logger.log(chalk.bold('\nPre-flight summary:'));
      -        logger.success(`Lines changed: ${chalk.green(`+${totalAdded}`)},
      ${chalk.red(`-${totalRemoved}`)}`);

      +        logger.success(`Lines changed: ${chalk.green(`+${totalAdded}`)},
      ${chalk.red(`-${totalRemoved}`)} (${chalk.yellow(`${totalDifference}
      total`)})`);
               logger.log(`Checks completed in ${chalk.gray(`${checksDuration.toFixed(2)}ms`)}`);
       
               const isApproved = await handleApproval({ config, cwd, prompter, skipConfirmation });
       
               if (isApproved) {
                   stateFile.approved = true;
      -            (stateFile as any).linesAdded = totalAdded;

      -            (stateFile as any).linesRemoved = totalRemoved;

      +            stateFile.linesAdded = totalAdded;

      +            stateFile.linesRemoved = totalRemoved;

      +            stateFile.linesDifference = totalDifference;
                   await updatePendingState(cwd, stateFile); // Update state with approval and stats before commit
                   await commitState(cwd, uuid);
                   logCompletionSummary(uuid, startTime, operations);
                   notifySuccess(uuid, config.core.enableNotifications);
                   await handleAutoGitBranch(config, stateFile, cwd);
               } else {
    patchStrategy: new-unified
  - type: write
    path: src/utils/formatters.ts
    content: >-
      --- src/utils/formatters.ts

      +++ src/utils/formatters.ts

      @@ -17,6 +17,13 @@
       
           if (tx.promptSummary) lines.push(`  ${chalk.bold('Prompt Summary')}: ${tx.promptSummary}`);
           if (tx.gitCommitMsg) lines.push(`  ${chalk.bold('Git Commit')}: "${tx.gitCommitMsg}"`);
      +

      +    const hasLineChanges = typeof tx.linesAdded === 'number' && typeof
      tx.linesRemoved === 'number';

      +    if (hasLineChanges) {

      +        const diffText = typeof tx.linesDifference === 'number' ? `
      (${chalk.yellow(`${tx.linesDifference} total`)})` : '';

      +        lines.push(`  ${chalk.bold('Lines Changed')}:
      ${chalk.green(`+${tx.linesAdded}`)},
      ${chalk.red(`-${tx.linesRemoved}`)}${diffText}`);

      +    }
       
           if (showReasoning && tx.reasoning && tx.reasoning.length > 0) {
               lines.push(`  ${chalk.bold('Reasoning')}:`);
    patchStrategy: new-unified
snapshot:
  packages/relaycode-core/src/patch.ts: |-
    import { FileOperation } from './types';
    import { applyStandardDiff, applySearchReplace } from 'apply-multi-diff';

    const patchStrategies = {
      'standard-diff': async (p: { originalContent: string; diffContent: string; }) => {
        const result = applyStandardDiff(p.originalContent, p.diffContent);
        if (result.success) return { success: true, content: result.content };
        return { success: false, error: result.error.message };
      },
      'search-replace': async (p: { originalContent: string; diffContent: string; }) => {
        const result = applySearchReplace(p.originalContent, p.diffContent);
        if (result.success) return { success: true, content: result.content };
        return { success: false, error: result.error.message };
      },
    };

    export type ApplyOperationsResult = 
        | { success: true; newFileStates: Map<string, string | null> }
        | { success: false; error: string };

    export const applyOperations = async (
        operations: FileOperation[],
        originalFiles: Map<string, string | null>
    ): Promise<ApplyOperationsResult> => {
        const fileStates = new Map<string, string | null>(originalFiles);

        for (const op of operations) {
            if (op.type === 'delete') {
                fileStates.set(op.path, null);
                continue;
            }
            if (op.type === 'rename') {
                const content = fileStates.get(op.from);
                if (content === undefined) {
                    return { success: false, error: `Cannot rename non-existent or untracked file: ${op.from}` };
                }
                fileStates.set(op.from, null);
                fileStates.set(op.to, content);
                continue;
            }

            let finalContent: string;
            const currentContent = fileStates.get(op.path) ?? null;

            if (op.patchStrategy === 'replace') {
                finalContent = op.content;
            } else {
                if (currentContent === null && op.patchStrategy === 'search-replace') {
                    return { success: false, error: `Cannot use 'search-replace' on a new file: ${op.path}` };
                }

                try {
                    const diffParams = {
                        originalContent: currentContent ?? '',
                        diffContent: op.content,
                    };
                    
                    const patcher = patchStrategies[op.patchStrategy as keyof typeof patchStrategies];
                    if (!patcher) {
                        return { success: false, error: `Unknown patch strategy: '${op.patchStrategy}'` };
                    }
                    
                    const result = await patcher(diffParams);
                    if (result.success) {
                        if (typeof result.content !== 'string') {
                            return { success: false, error: `Patch for ${op.path} succeeded but returned no content.` };
                        }
                        finalContent = result.content;
                    } else {
                        return { success: false, error: `Patch failed for ${op.path}: ${result.error}` };
                    }
                } catch (e) {
                    const message = e instanceof Error ? e.message : String(e);
                    return { success: false, error: `Error applying patch for ${op.path} with strategy '${op.patchStrategy}': ${message}` };
                }
            }
            fileStates.set(op.path, finalContent);
        }

        return { success: true, newFileStates: fileStates };
    };

    const calculateLcsLength = (a: string[], b: string[]): number => {
        let s1 = a;
        let s2 = b;
        if (s1.length < s2.length) {
            [s1, s2] = [s2, s1];
        }
        const m = s1.length;
        const n = s2.length;
        
        const dp = Array(n + 1).fill(0);

        for (let i = 1; i <= m; i++) {
            let prev = 0;
            for (let j = 1; j <= n; j++) {
                const temp = dp[j];
                if (s1[i - 1] === s2[j - 1]) {
                    dp[j] = prev + 1;
                } else {
                    dp[j] = Math.max(dp[j], dp[j - 1]);
                }
                prev = temp;
            }
        }
        return dp[n];
    };

    export const calculateLineChanges = (
        op: FileOperation,
        originalFiles: Map<string, string | null>,
        newFiles: Map<string, string | null>
    ): { added: number; removed: number } => {
        if (op.type === 'rename') {
            return { added: 0, removed: 0 };
        }
        const oldContent = originalFiles.get(op.path) ?? null;

        if (op.type === 'delete') {
            const oldLines = oldContent ? oldContent.split('\n') : [];
            return { added: 0, removed: oldLines.length };
        }
        
        const newContent = newFiles.get(op.path) ?? null;

        if (oldContent === newContent) return { added: 0, removed: 0 };

        const oldLines = oldContent?.split('\n') ?? [];
        const newLines = newContent?.split('\n') ?? [];

        if (oldContent === null || oldContent === '') return { added: newLines.length, removed: 0 };
        if (newContent === null || newContent === '') return { added: 0, removed: oldLines.length };
        
        const lcsLength = calculateLcsLength(oldLines, newLines);
        return {
            added: newLines.length - lcsLength,
            removed: oldLines.length - lcsLength,
        };
    };
  packages/relaycode-core/src/types.ts: >-
    import { z } from 'zod';


    export const LogLevelNameSchema = z.enum(['silent', 'error', 'warn', 'info',
    'debug']).default('info');

    export type LogLevelName = z.infer<typeof LogLevelNameSchema>;


    // Schema for relaycode.config.json

    const CoreConfigSchema = z.object({
      logLevel: LogLevelNameSchema,
      enableNotifications: z.boolean().default(true),
      watchConfig: z.boolean().default(true),
    });


    const WatcherConfigSchema = z.object({
      clipboardPollInterval: z.number().int().positive().default(2000),
      preferredStrategy: z.enum(['auto', 'replace', 'standard-diff', 'search-replace']).default('auto'),
    });


    const PatchConfigSchema = z.object({
      approvalMode: z.enum(['auto', 'manual']).default('auto'),
      approvalOnErrorCount: z.number().int().min(0).default(0),
      linter: z.string().default('bun tsc --noEmit'),
      preCommand: z.string().default(''),
      postCommand: z.string().default(''),
      minFileChanges: z.number().int().min(0).default(0),
      maxFileChanges: z.number().int().min(1).optional(),
    });


    const GitConfigSchema = z.object({
      autoGitBranch: z.boolean().default(false),
      gitBranchPrefix: z.string().default('relay/'),
      gitBranchTemplate: z.enum(['uuid', 'gitCommitMsg']).default('gitCommitMsg'),
    });


    const BaseConfigSchema = z.object({
      projectId: z.string().min(1),
      core: CoreConfigSchema,
      watcher: WatcherConfigSchema,
      patch: PatchConfigSchema,
      git: GitConfigSchema,
    });


    export const ConfigSchema = BaseConfigSchema.deepPartial().extend({
      projectId: z.string().min(1),
    }).transform(val => ({
      projectId: val.projectId,
      core: CoreConfigSchema.parse(val.core ?? {}),
      watcher: WatcherConfigSchema.parse(val.watcher ?? {}),
      patch: PatchConfigSchema.parse(val.patch ?? {}),
      git: GitConfigSchema.parse(val.git ?? {}),
    }));

    export type Config = z.infer<typeof ConfigSchema>;


    export type RelayCodeConfigInput = z.input<typeof ConfigSchema>;

    export const defineConfig = (config: RelayCodeConfigInput):
    RelayCodeConfigInput => config;


    export const PatchStrategySchema = z.enum([
      'replace',
      'standard-diff',
      'search-replace',
    ]).default('replace');

    export type PatchStrategy = z.infer<typeof PatchStrategySchema>;


    export const FileSnapshotSchema = z.record(z.string(),
    z.string().nullable());

    export type FileSnapshot = z.infer<typeof FileSnapshotSchema>;


    // Schema for operations parsed from code blocks

    export const FileOperationSchema = z.union([
      z.object({
        type: z.literal('write'),
        path: z.string(),
        content: z.string(),
        patchStrategy: PatchStrategySchema,
      }),
      z.object({
        type: z.literal('delete'),
        path: z.string(),
      }),
      z.object({
        type: z.literal('rename'),
        from: z.string(),
        to: z.string(),
      }),
    ]);

    export type FileOperation = z.infer<typeof FileOperationSchema>;


    // Schema for the state file (transaction record)

    export const StateFileSchema = z.object({
      uuid: z.string().uuid(),
      projectId: z.string(),
      createdAt: z.string(), // ISO string
      linesAdded: z.number().optional(),
      linesRemoved: z.number().optional(),
      gitCommitMsg: z.string().optional(),
      promptSummary: z.string().optional(),
      reasoning: z.array(z.string()),
      operations: z.array(FileOperationSchema),
      snapshot: FileSnapshotSchema,
      approved: z.boolean(),
    });

    export type StateFile = z.infer<typeof StateFileSchema>;


    // Schema for the control YAML block at the end of the LLM response

    export const ControlYamlSchema = z.object({
      projectId: z.string(),
      uuid: z.string().uuid(),
      changeSummary: z.array(z.record(z.string(), z.string())).optional(), // Not strictly used, but good to parse
      gitCommitMsg: z.string().optional(),
      promptSummary: z.string().optional(),
    });

    export type ControlYaml = z.infer<typeof ControlYamlSchema>;


    // The fully parsed response from the clipboard

    export const ParsedLLMResponseSchema = z.object({
      control: ControlYamlSchema,
      operations: z.array(FileOperationSchema),
      reasoning: z.array(z.string()),
    });

    export type ParsedLLMResponse = z.infer<typeof ParsedLLMResponseSchema>;
  src/core/db.ts: >-
    import { konro } from 'konro';

    import type { FileOperation, FileSnapshot, StateFile } from
    'relaycode-core';

    import path from 'path';

    import { getStateDirectory } from './config';

    import type { OnDemandDbContext } from 'konro';


    export const relaySchema = konro.createSchema({
      tables: {
        transactions: {
          id: konro.id(),
          uuid: konro.string({ unique: true }),
          projectId: konro.string(),
          createdAt: konro.string(), // store as ISO string
          linesAdded: konro.number({ optional: true }),
          linesRemoved: konro.number({ optional: true }),
          gitCommitMsg: konro.string({ optional: true }),
          gitCommittedAt: konro.string({ optional: true }), // ISO string timestamp when included in git commit
          promptSummary: konro.string({ optional: true }),
          reasoning: konro.object<string[]>(),
          operations: konro.object<FileOperation[]>(),
          snapshot: konro.object<FileSnapshot>(),
          approved: konro.boolean(),
          status: konro.string(), // 'pending', 'committed', 'undone'
        },
      },
      relations: () => ({}),
    });


    export type RelaySchema = typeof relaySchema;

    // This is the type inferred by konro for a base record.

    export type TransactionRecord = RelaySchema['base']['transactions'];


    // We need to convert between TransactionRecord and StateFile because
    StateFile is a Zod-validated type

    // and TransactionRecord is konro's inferred type. They should be
    structurally identical.

    // This function also handles type casting for complex object types.

    export function toStateFile(record: TransactionRecord): StateFile {
      return record as unknown as StateFile;
    }


    export function fromStateFile(stateFile: StateFile): Omit<TransactionRecord,
    'id' | 'status'> {
      return {
        ...stateFile,
        linesAdded: stateFile.linesAdded ?? null,
        linesRemoved: stateFile.linesRemoved ?? null,
        gitCommitMsg: stateFile.gitCommitMsg ?? null,
        gitCommittedAt: (stateFile as any).gitCommittedAt ?? null,
        promptSummary: stateFile.promptSummary ?? null,
      };
    }


    const dbInstances = new Map<string, OnDemandDbContext<RelaySchema>>();


    export function getDb(cwd: string): OnDemandDbContext<RelaySchema> {
      const resolvedCwd = path.resolve(cwd);
      const existingInstance = dbInstances.get(resolvedCwd);
      if (existingInstance) {
        return existingInstance;
      }

      const dbDir = path.join(getStateDirectory(resolvedCwd), 'db');

      const adapter = konro.createFileAdapter({
        format: 'json',
        perRecord: { dir: dbDir },
        mode: 'on-demand',
      });

      const db = konro.createDatabase({ schema: relaySchema, adapter });
      const newInstance = db as OnDemandDbContext<RelaySchema>;
      dbInstances.set(resolvedCwd, newInstance);
      return newInstance;
    }
  src/core/transaction.ts: >
    import { Config, ParsedLLMResponse, StateFile, FileSnapshot, FileOperation }
    from 'relaycode-core';

    import { logger, getErrorMessage } from '../utils/logger';

    import { getErrorCount, executeShellCommand } from '../utils/shell';

    import { deleteFile, readFileContent, removeEmptyParentDirectories,
    renameFile, writeFileContent } from '../utils/fs';

    import path from 'path';

    import chalk from 'chalk';

    import { applyOperations as applyOperationsCore, calculateLineChanges as
    calculateLineChangesCore } from 'relaycode-core';


    import { hasBeenProcessed, writePendingState, commitState,
    deletePendingState, updatePendingState } from './state';

    import { getConfirmation } from '../utils/prompt';

    import { requestApprovalWithNotification, notifyFailure, notifySuccess,
    notifyPatchDetected, notifyRollbackFailure } from '../utils/notifier';


    type Prompter = (question: string) => Promise<boolean>;


    type ProcessPatchOptions = {
        prompter?: Prompter;
        cwd?: string;
        notifyOnStart?: boolean;
        yes?: boolean;
    };


    export const createSnapshot = async (filePaths: string[], cwd: string =
    process.cwd()): Promise<FileSnapshot> => {
      const snapshot: FileSnapshot = {};
      await Promise.all(
        filePaths.map(async (filePath) => {
          snapshot[filePath] = await readFileContent(filePath, cwd);
        })
      );
      return snapshot;
    };


    /**
     * Applies a series of file operations to the filesystem and returns the new in-memory file states.
     * This function processes operations sequentially, applying patches (like diffs) against the evolving
     * state of files, and performing filesystem actions (write, delete, rename) along the way.
     * @param operations The file operations to apply.
     * @param originalFiles The initial state of the files.
     * @param cwd The working directory.
     * @returns A map representing the final state of all affected files.
     */
    export const applyOperations = async (
      operations: FileOperation[],
      originalFiles: Map<string, string | null>,
      cwd: string = process.cwd()
    ): Promise<Map<string, string | null>> => {
      // This map tracks the evolving in--memory state of files as we apply operations.
      const fileStates = new Map<string, string | null>(originalFiles);

      for (const op of operations) {
        if (op.type === 'delete') {
          if (!fileStates.has(op.path) || fileStates.get(op.path) === null) {
            throw new Error(`Attempted to delete a file that does not exist or was already deleted: ${op.path}`);
          }
          await deleteFile(op.path, cwd);
          fileStates.set(op.path, null);
        } else if (op.type === 'rename') {
          await renameFile(op.from, op.to, cwd);
          const content = fileStates.get(op.from);
          fileStates.set(op.from, null);
          if (content !== undefined) {
            fileStates.set(op.to, content);
          }
        } else if (op.type === 'write') {
          // For a write operation (which could be a patch), we apply it to the current in-memory state.
          const singleOpResult = await applyOperationsCore([op], fileStates);
          if (!singleOpResult.success) {
            throw new Error(`Failed applying single write op to ${op.path}: ${singleOpResult.error}`);
          }
          
          const newContent = singleOpResult.newFileStates.get(op.path);
          if (typeof newContent === 'string') {
            await writeFileContent(op.path, newContent, cwd);
            fileStates.set(op.path, newContent);
          }
        }
      }
      return fileStates;
    };


    export const restoreSnapshot = async (snapshot: FileSnapshot, cwd: string =
    process.cwd()): Promise<void> => {
      const projectRoot = path.resolve(cwd);
      const entries = Object.entries(snapshot);
      const directoriesToClean = new Set<string>();
      const restoreErrors: { path: string, error: unknown }[] = [];

      // Attempt to restore all files in parallel, collecting errors.
      await Promise.all(entries.map(async ([filePath, content]) => {
          const fullPath = path.resolve(cwd, filePath);
          try {
            if (content === null) {
              // If the file didn't exist in the snapshot, make sure it doesn't exist after restore.
              await deleteFile(filePath, cwd);
              directoriesToClean.add(path.dirname(fullPath));
            } else {
              // Create directory structure if needed and write the original content back.
              await writeFileContent(filePath, content, cwd);
            }
          } catch (error) {
            restoreErrors.push({ path: filePath, error });
          }
      }));
      
      // After all files are processed, clean up empty directories
      // Sort directories by depth (deepest first) to clean up nested empty dirs properly
      const sortedDirs = Array.from(directoriesToClean)
        .sort((a, b) => b.split(path.sep).length - a.split(path.sep).length);
      
      // Process each directory that had files deleted
      for (const dir of sortedDirs) {
        await removeEmptyParentDirectories(dir, projectRoot);
      }

      if (restoreErrors.length > 0) {
        const errorSummary = restoreErrors
          .map(e => `  - ${e.path}: ${getErrorMessage(e.error)}`)
          .join('\n');
        throw new Error(`Rollback failed for ${restoreErrors.length} file(s):\n${errorSummary}`);
      }
    };


    const calculateLineChanges = (
        op: FileOperation,
        originalFiles: Map<string, string | null>,
        newFiles: Map<string, string | null>
    ): { added: number; removed: number } => {
        // Simply delegate to the core function.
        // The core function's signature is slightly different, but it serves the same purpose.
        return calculateLineChangesCore(op, originalFiles, newFiles);
    };


    const logCompletionSummary = (
        uuid: string,
        startTime: number,
        operations: FileOperation[]
    ) => {
        const duration = performance.now() - startTime;

        logger.log(chalk.bold('\nSummary:'));
        logger.log(`Applied ${chalk.cyan(operations.length)} file operation(s) successfully.`);
        logger.log(`Total time from start to commit: ${chalk.gray(`${duration.toFixed(2)}ms`)}`);
        logger.success(`✅ Transaction ${chalk.gray(uuid)} committed successfully!`);
    };


    const rollbackTransaction = async (cwd: string, uuid: string, snapshot:
    FileSnapshot, reason: string, enableNotifications: boolean = true, isError:
    boolean = true): Promise<void> => {
        if (isError) {
            logger.warn(`Rolling back changes: ${reason}`);
        }

        let rollbackSuccessful = false;
        try {
            await restoreSnapshot(snapshot, cwd);
            logger.success('  - Files restored to original state.');
            rollbackSuccessful = true;
        } catch (error) {
            logger.error(`Fatal: Rollback failed: ${getErrorMessage(error)}`);
            notifyRollbackFailure(uuid, enableNotifications);
            // Do not rethrow; we're already in a final error handling state.
        } finally {
            try {
                await deletePendingState(cwd, uuid);
                logger.info(`↩️ Transaction ${chalk.gray(uuid)} rolled back.`);
                if (isError && rollbackSuccessful) {
                    notifyFailure(uuid, enableNotifications);
                }
            } catch (cleanupError) {
                logger.error(`Fatal: Could not clean up pending state for ${chalk.gray(uuid)}: ${getErrorMessage(cleanupError)}`);
            }
        }
    };


    type ApprovalOptions = {
        config: Config;
        cwd: string;
        prompter: Prompter;
        skipConfirmation: boolean;
    }


    const handleApproval = async ({ config, cwd, prompter, skipConfirmation }:
    ApprovalOptions): Promise<boolean> => {
        const finalErrorCount = await getErrorCount(config.patch.linter, cwd);
        logger.log(`  - Final linter error count: ${finalErrorCount > 0 ? chalk.red(finalErrorCount) : chalk.green(finalErrorCount)}`);
        
        const getManualApproval = async (reason: string): Promise<boolean> => {
            logger.warn(reason);
            
            const notificationResult = await requestApprovalWithNotification(config.projectId, config.core.enableNotifications);

            if (notificationResult === 'approved') {
                logger.info('Approved via notification.');
                return true;
            }
            if (notificationResult === 'rejected') {
                logger.info('Rejected via notification.');
                return false;
            }

            if (notificationResult === 'timeout') {
                logger.info('Notification timed out or was dismissed. Please use the terminal to respond.');
            }

            return await prompter('Changes applied. Do you want to approve and commit them? (y/N)');
        };

        if (skipConfirmation) {
            logger.success('  - Changes approved via -y/--yes flag.');
            return true;
        }
        if (config.patch.approvalMode === 'manual') {
            return await getManualApproval('Manual approval required because "approvalMode" is set to "manual".');
        }
        // auto mode
        const canAutoApprove = finalErrorCount <= config.patch.approvalOnErrorCount;
        if (canAutoApprove) {
            logger.success('  - Changes automatically approved based on your configuration.');
            return true;
        }
        return await getManualApproval(`Manual approval required: Linter found ${finalErrorCount} error(s) (threshold is ${config.patch.approvalOnErrorCount}).`);
    };


    export const processPatch = async (config: Config, parsedResponse:
    ParsedLLMResponse, options?: ProcessPatchOptions): Promise<void> => {
        const cwd = options?.cwd || process.cwd();
        const prompter = options?.prompter || getConfirmation;
        const skipConfirmation = options?.yes === true;
        const notifyOnStart = options?.notifyOnStart ?? false;
        const { control, operations, reasoning } = parsedResponse;
        const { uuid, projectId } = control;
        const startTime = performance.now();

        // 1. Validation
        if (projectId !== config.projectId) {
            logger.warn(`Skipping patch: projectId mismatch (expected '${chalk.cyan(config.projectId)}', got '${chalk.cyan(projectId)}').`);
            return;
        }
        if (await hasBeenProcessed(cwd, uuid)) {
            logger.info(`Skipping patch: uuid '${chalk.gray(uuid)}' has already been processed.`);
            return;
        }

        const { minFileChanges, maxFileChanges } = config.patch;
        const operationCount = operations.length;
        if (minFileChanges > 0 && operationCount < minFileChanges) {
            logger.warn(`Skipping patch: Not enough file changes (expected at least ${minFileChanges}, got ${operationCount}).`);
            return;
        }
        if (maxFileChanges && operationCount > maxFileChanges) {
            logger.warn(`Skipping patch: Too many file changes (expected at most ${maxFileChanges}, got ${operationCount}).`);
            return;
        }

        // Notify if coming from watch mode, now that we know it's a new patch.
        if (notifyOnStart) {
            notifyPatchDetected(config.projectId, config.core.enableNotifications);
            logger.success(`Valid patch detected for project '${chalk.cyan(config.projectId)}'. Processing...`);
        }

        // 2. Pre-flight checks
        if (config.patch.preCommand) {
            logger.log(`  - Running pre-command: ${chalk.magenta(config.patch.preCommand)}`);
            const { exitCode, stderr } = await executeShellCommand(config.patch.preCommand, cwd);
            if (exitCode !== 0) {
                logger.error(`Pre-command failed with exit code ${chalk.red(exitCode)}, aborting transaction.`);
                if (stderr) logger.error(`Stderr: ${stderr}`);
                return;
            }
        }

        logger.info(`🚀 Starting transaction for patch ${chalk.gray(uuid)}...`);
        logger.log(`${chalk.bold('Reasoning:')}\n  ${reasoning.join('\n  ')}`);

        const affectedFilePaths = operations.reduce<string[]>((acc, op) => {
            if (op.type === 'rename') {
                acc.push(op.from, op.to);
            } else {
                acc.push(op.path);
            }
            return acc;
        }, []);
        const snapshot = await createSnapshot(affectedFilePaths, cwd);
        
        const stateFile: StateFile = {
            uuid,
            projectId,
            createdAt: new Date().toISOString(),
            gitCommitMsg: control.gitCommitMsg,
            promptSummary: control.promptSummary,
            reasoning,
            operations,
            snapshot,
            approved: false,
        };

        try {
            await writePendingState(cwd, stateFile);
            logger.success('  - Staged changes to .pending.yml file.');

            const originalFiles = new Map<string, string | null>();
            affectedFilePaths.forEach(p => originalFiles.set(p, snapshot[p] ?? null));

            // Apply changes
            logger.log('  - Applying file operations...');
            const newFileStates = await applyOperations(operations, originalFiles, cwd);
            logger.success('  - File operations complete.');

            const opStats = operations.map(op => {
                const stats = calculateLineChanges(op, originalFiles, newFileStates);
                if (op.type === 'write') {
                    logger.success(`✔ Written: ${chalk.cyan(op.path)} (${chalk.green(`+${stats.added}`)}, ${chalk.red(`-${stats.removed}`)})`);
                } else if (op.type === 'delete') {
                    logger.success(`✔ Deleted: ${chalk.cyan(op.path)}`);
                } else if (op.type === 'rename') {
                    logger.success(`✔ Renamed: ${chalk.cyan(op.from)} -> ${chalk.cyan(op.to)}`);
                }
                return stats;
            });

            // Run post-command
            if (config.patch.postCommand) {
                logger.log(`  - Running post-command: ${chalk.magenta(config.patch.postCommand)}`);
                const postResult = await executeShellCommand(config.patch.postCommand, cwd);
                if (postResult.exitCode !== 0) {
                    logger.error(`Post-command failed with exit code ${chalk.red(postResult.exitCode)}.`);
                    if (postResult.stderr) logger.error(`Stderr: ${postResult.stderr}`);
                    throw new Error('Post-command failed, forcing rollback.');
                }
            }

            // Log summary before asking for approval
            const checksDuration = performance.now() - startTime;
            const totalAdded = opStats.reduce((sum, s) => sum + s.added, 0);
            const totalRemoved = opStats.reduce((sum, s) => sum + s.removed, 0);

            logger.log(chalk.bold('\nPre-flight summary:'));
            logger.success(`Lines changed: ${chalk.green(`+${totalAdded}`)}, ${chalk.red(`-${totalRemoved}`)}`);
            logger.log(`Checks completed in ${chalk.gray(`${checksDuration.toFixed(2)}ms`)}`);

            const isApproved = await handleApproval({ config, cwd, prompter, skipConfirmation });

            if (isApproved) {
                stateFile.approved = true;
                (stateFile as any).linesAdded = totalAdded;
                (stateFile as any).linesRemoved = totalRemoved;
                await updatePendingState(cwd, stateFile); // Update state with approval and stats before commit
                await commitState(cwd, uuid);
                logCompletionSummary(uuid, startTime, operations);
                notifySuccess(uuid, config.core.enableNotifications);
                await handleAutoGitBranch(config, stateFile, cwd);
            } else {
                logger.warn('Operation cancelled by user. Rolling back changes...');
                await rollbackTransaction(cwd, uuid, snapshot, 'User cancellation', config.core.enableNotifications, false);
            }
        } catch (error) {
            const reason = getErrorMessage(error);
            await rollbackTransaction(cwd, uuid, snapshot, reason, config.core.enableNotifications, true);
        }
    };


    const handleAutoGitBranch = async (config: Config, stateFile: StateFile,
    cwd: string): Promise<void> => {
        if (!config.git.autoGitBranch) return;

        let branchNameSegment = '';
        if (config.git.gitBranchTemplate === 'gitCommitMsg' && stateFile.gitCommitMsg) {
            branchNameSegment = stateFile.gitCommitMsg;
        } else {
            branchNameSegment = stateFile.uuid;
        }

        const sanitizedSegment = branchNameSegment
            .trim()
            .toLowerCase()
            .replace(/[^\w\s-]/g, '') // Remove all non-word, non-space, non-hyphen chars
            .replace(/[\s_]+/g, '-') // Replace spaces and underscores with a single hyphen
            .replace(/-+/g, '-') // Collapse consecutive hyphens
            .replace(/^-|-$/g, '') // Trim leading/trailing hyphens
            .slice(0, 70); // Truncate

        if (sanitizedSegment) {
            const branchName = `${config.git.gitBranchPrefix}${sanitizedSegment}`;
            logger.info(`Creating and switching to new git branch: ${chalk.magenta(branchName)}`);
            const command = `git checkout -b "${branchName}"`;
            const result = await executeShellCommand(command, cwd);
            if (result.exitCode === 0) {
                logger.success(`Successfully created and switched to branch '${chalk.magenta(branchName)}'.`);
            } else {
                // Exit code 128 from `git checkout -b` often means the branch already exists.
                if (result.exitCode === 128 && result.stderr.includes('already exists')) {
                    logger.warn(`Could not create branch '${chalk.magenta(branchName)}' because it already exists.`);
                } else {
                    logger.warn(`Could not create git branch '${chalk.magenta(branchName)}'.`);
                }
                logger.debug(`'${command}' failed with: ${result.stderr}`);
            }
        } else {
            logger.warn('Could not generate a branch name segment from commit message or UUID. Skipping git branch creation.');
        }
    };
  src/utils/formatters.ts: |-
    import chalk from 'chalk';
    import { FileOperation, StateFile } from 'relaycode-core';

    const opToString = (op: FileOperation): string => {
        switch (op.type) {
            case 'write': return `${chalk.green('write')}:  ${chalk.cyan(op.path)}`;
            case 'delete': return `${chalk.red('delete')}: ${chalk.cyan(op.path)}`;
            case 'rename': return `${chalk.yellow('rename')}: ${chalk.cyan(op.from)} -> ${chalk.cyan(op.to)}`;
        }
    };

    export const formatTransactionDetails = (
        tx: StateFile,
        options: { showOperations?: boolean, showSpacing?: boolean, showReasoning?: boolean } = {}
    ): string[] => {
        const { showOperations, showSpacing, showReasoning = true } = options;
        const lines: string[] = [
            `- ${chalk.bold('UUID')}: ${chalk.gray(tx.uuid)}`,
            `  ${chalk.bold('Date')}: ${new Date(tx.createdAt).toLocaleString()}`,
        ];

        if (tx.promptSummary) lines.push(`  ${chalk.bold('Prompt Summary')}: ${tx.promptSummary}`);
        if (tx.gitCommitMsg) lines.push(`  ${chalk.bold('Git Commit')}: "${tx.gitCommitMsg}"`);

        if (showReasoning && tx.reasoning && tx.reasoning.length > 0) {
            lines.push(`  ${chalk.bold('Reasoning')}:`);
            tx.reasoning.forEach(r => lines.push(`    - ${r}`));
        }
        if (showOperations && tx.operations && tx.operations.length > 0) {
            lines.push(`  ${chalk.bold('Changes')}:`);
            tx.operations.forEach(op => lines.push(`    - ${opToString(op)}`));
        }
        if (showSpacing) {
            lines.push(''); // Newline for spacing
        }
        return lines;
    };
approved: true
