uuid: ca4546ae-e95e-4b68-b769-e0e972f10b7f
projectId: relaycode
createdAt: '2025-09-03T07:42:07.452Z'
linesAdded: 9
linesRemoved: 15
gitCommitMsg: 'refactor(core): align patch strategy names with apply-multi-diff'
promptSummary: >-
  Fix TypeScript errors by refactoring patch strategy names in relaycode-core to
  align with apply-multi-diff library's StandardDiff and SearchReplace
  strategies.
reasoning:
  - >-
    ok, got it. the patch strategy names in `relaycode-core` are out of sync
    with `apply-multi-diff` and what the tests expect. i'll refactor
    `relaycode-core` to use `standard-diff` and `search-replace` consistently.
  - >-
    first, i'll update `PatchStrategySchema` and `WatcherConfigSchema` in
    `relaycode-core/src/types.ts` to use the correct strategy names. this will
    fix the type errors.
  - >-
    next, i'll update the `inferPatchStrategy` function in
    `relaycode-core/src/parser.ts` to return the new, correct strategy names.
  - >-
    finally, i'll update the `patchStrategies` map in
    `relaycode-core/src/patch.ts` to use the new keys and remove the redundant
    ones. this makes it consistent with `apply-multi-diff`.
operations:
  - type: write
    path: packages/relaycode-core/src/types.ts
    content: >-
      --- packages/relaycode-core/src/types.ts

      +++ packages/relaycode-core/src/types.ts

      @@ -11,7 +11,7 @@
       
       const WatcherConfigSchema = z.object({
         clipboardPollInterval: z.number().int().positive().default(2000),
      -  preferredStrategy: z.enum(['auto', 'replace', 'new-unified',
      'multi-search-replace']).default('auto'),

      +  preferredStrategy: z.enum(['auto', 'replace', 'standard-diff',
      'search-replace']).default('auto'),
       });
       
       const PatchConfigSchema = z.object({
      @@ -46,11 +46,9 @@
       
       export const PatchStrategySchema = z.enum([
         'replace',
      -  'new-unified',

      -  'multi-search-replace',

      -  'unified',

      +  'standard-diff',

      +  'search-replace',
       ]).default('replace');
       export type PatchStrategy = z.infer<typeof PatchStrategySchema>;
       
       export const FileSnapshotSchema = z.record(z.string(), z.string().nullable());
    patchStrategy: new-unified
  - type: write
    path: packages/relaycode-core/src/parser.ts
    content: >-
      --- packages/relaycode-core/src/parser.ts

      +++ packages/relaycode-core/src/parser.ts

      @@ -62,8 +62,8 @@
       
       const inferPatchStrategy = (content: string, providedStrategy: PatchStrategy | null): PatchStrategy => {
           if (providedStrategy) return providedStrategy;
      -    if (/^<<<<<<< SEARCH\s*$/m.test(content) && content.includes('>>>>>>>
      REPLACE')) return 'multi-search-replace';

      -    if (content.startsWith('--- ') && content.includes('+++ ') &&
      content.includes('@@')) return 'new-unified';

      +    if (/^<<<<<<< SEARCH\s*$/m.test(content) && content.includes('>>>>>>>
      REPLACE')) return 'search-replace';

      +    if (content.startsWith('--- ') && content.includes('+++ ') &&
      content.includes('@@')) return 'standard-diff';
           return 'replace';
       };
    patchStrategy: new-unified
  - type: write
    path: packages/relaycode-core/src/patch.ts
    content: >-
      --- packages/relaycode-core/src/patch.ts

      +++ packages/relaycode-core/src/patch.ts

      @@ -1,22 +1,15 @@
       import { FileOperation } from './types';
       import { applyStandardDiff, applySearchReplace } from 'apply-multi-diff';
       
       const patchStrategies = {
      -  'new-unified': async (p: { originalContent: string; diffContent:
      string; }) => {

      +  'standard-diff': async (p: { originalContent: string; diffContent:
      string; }) => {
           const result = applyStandardDiff(p.originalContent, p.diffContent);
           if (result.success) return { success: true, content: result.content };
           return { success: false, error: result.error.message };
         },
      -  'multi-search-replace': async (p: { originalContent: string;
      diffContent: string; }) => {

      +  'search-replace': async (p: { originalContent: string; diffContent:
      string; }) => {
           const result = applySearchReplace(p.originalContent, p.diffContent);
           if (result.success) return { success: true, content: result.content };
           return { success: false, error: result.error.message };
         },
      -  'unified': async (p: { originalContent: string; diffContent: string; })
      => {

      -    const result = applyStandardDiff(p.originalContent, p.diffContent);

      -    if (result.success) return { success: true, content: result.content
      };

      -    return { success: false, error: result.error.message };

      -  },
       };
       
       export type ApplyOperationsResult = 
      @@ -51,8 +44,8 @@
               if (op.patchStrategy === 'replace') {
                   finalContent = op.content;
               } else {
      -            if (currentContent === null && op.patchStrategy ===
      'multi-search-replace') {

      -                return { success: false, error: `Cannot use
      'multi-search-replace' on a new file: ${op.path}` };

      +            if (currentContent === null && op.patchStrategy ===
      'search-replace') {

      +                return { success: false, error: `Cannot use
      'search-replace' on a new file: ${op.path}` };
                   }
       
                   try {
    patchStrategy: new-unified
snapshot:
  packages/relaycode-core/src/types.ts: >-
    import { z } from 'zod';


    export const LogLevelNameSchema = z.enum(['silent', 'error', 'warn', 'info',
    'debug']).default('info');

    export type LogLevelName = z.infer<typeof LogLevelNameSchema>;


    // Schema for relaycode.config.json

    const CoreConfigSchema = z.object({
      logLevel: LogLevelNameSchema,
      enableNotifications: z.boolean().default(true),
      watchConfig: z.boolean().default(true),
    });


    const WatcherConfigSchema = z.object({
      clipboardPollInterval: z.number().int().positive().default(2000),
      preferredStrategy: z.enum(['auto', 'replace', 'new-unified', 'multi-search-replace']).default('auto'),
    });


    const PatchConfigSchema = z.object({
      approvalMode: z.enum(['auto', 'manual']).default('auto'),
      approvalOnErrorCount: z.number().int().min(0).default(0),
      linter: z.string().default('bun tsc --noEmit'),
      preCommand: z.string().default(''),
      postCommand: z.string().default(''),
      minFileChanges: z.number().int().min(0).default(0),
      maxFileChanges: z.number().int().min(1).optional(),
    });


    const GitConfigSchema = z.object({
      autoGitBranch: z.boolean().default(false),
      gitBranchPrefix: z.string().default('relay/'),
      gitBranchTemplate: z.enum(['uuid', 'gitCommitMsg']).default('gitCommitMsg'),
    });


    const BaseConfigSchema = z.object({
      projectId: z.string().min(1),
      core: CoreConfigSchema,
      watcher: WatcherConfigSchema,
      patch: PatchConfigSchema,
      git: GitConfigSchema,
    });


    export const ConfigSchema = BaseConfigSchema.deepPartial().extend({
      projectId: z.string().min(1),
    }).transform(val => ({
      projectId: val.projectId,
      core: CoreConfigSchema.parse(val.core ?? {}),
      watcher: WatcherConfigSchema.parse(val.watcher ?? {}),
      patch: PatchConfigSchema.parse(val.patch ?? {}),
      git: GitConfigSchema.parse(val.git ?? {}),
    }));

    export type Config = z.infer<typeof ConfigSchema>;


    export type RelayCodeConfigInput = z.input<typeof ConfigSchema>;

    export const defineConfig = (config: RelayCodeConfigInput):
    RelayCodeConfigInput => config;


    export const PatchStrategySchema = z.enum([
      'replace',
      'new-unified',
      'multi-search-replace',
      'unified',
    ]).default('replace');

    export type PatchStrategy = z.infer<typeof PatchStrategySchema>;


    export const FileSnapshotSchema = z.record(z.string(),
    z.string().nullable());

    export type FileSnapshot = z.infer<typeof FileSnapshotSchema>;


    // Schema for operations parsed from code blocks

    export const FileOperationSchema = z.union([
      z.object({
        type: z.literal('write'),
        path: z.string(),
        content: z.string(),
        patchStrategy: PatchStrategySchema,
      }),
      z.object({
        type: z.literal('delete'),
        path: z.string(),
      }),
      z.object({
        type: z.literal('rename'),
        from: z.string(),
        to: z.string(),
      }),
    ]);

    export type FileOperation = z.infer<typeof FileOperationSchema>;


    // Schema for the state file (transaction record)

    export const StateFileSchema = z.object({
      uuid: z.string().uuid(),
      projectId: z.string(),
      createdAt: z.string(), // ISO string
      linesAdded: z.number().optional(),
      linesRemoved: z.number().optional(),
      gitCommitMsg: z.string().optional(),
      promptSummary: z.string().optional(),
      reasoning: z.array(z.string()),
      operations: z.array(FileOperationSchema),
      snapshot: FileSnapshotSchema,
      approved: z.boolean(),
    });

    export type StateFile = z.infer<typeof StateFileSchema>;


    // Schema for the control YAML block at the end of the LLM response

    export const ControlYamlSchema = z.object({
      projectId: z.string(),
      uuid: z.string().uuid(),
      changeSummary: z.array(z.record(z.string(), z.string())).optional(), // Not strictly used, but good to parse
      gitCommitMsg: z.string().optional(),
      promptSummary: z.string().optional(),
    });

    export type ControlYaml = z.infer<typeof ControlYamlSchema>;


    // The fully parsed response from the clipboard

    export const ParsedLLMResponseSchema = z.object({
      control: ControlYamlSchema,
      operations: z.array(FileOperationSchema),
      reasoning: z.array(z.string()),
    });

    export type ParsedLLMResponse = z.infer<typeof ParsedLLMResponseSchema>;
  packages/relaycode-core/src/parser.ts: >-
    import yaml from 'js-yaml';

    import { z } from 'zod';

    import {
        ControlYamlSchema,
        FileOperation,
        ParsedLLMResponse,
        ParsedLLMResponseSchema,
        PatchStrategy,
        PatchStrategySchema,
    } from './types';

    import {
        CODE_BLOCK_START_MARKER,
        CODE_BLOCK_END_MARKER,
        DELETE_FILE_MARKER,
        RENAME_FILE_OPERATION
    } from './constants';


    const CODE_BLOCK_REGEX =
    /```(?:\w+)?(?:\s*\/\/\s*(.*?)|\s+(.*?))?[\r\n]([\s\S]*?)[\r\n]```/g;


    type ParsedHeader = {
        filePath: string;
        patchStrategy: PatchStrategy | null;
    };


    const extractCodeBetweenMarkers = (content: string): string => {
        const startMarkerIndex = content.indexOf(CODE_BLOCK_START_MARKER);
        const endMarkerIndex = content.lastIndexOf(CODE_BLOCK_END_MARKER);    
        
        let relevantContent = content;
        if (startMarkerIndex !== -1 && endMarkerIndex !== -1 && endMarkerIndex > startMarkerIndex) {
            relevantContent = content.substring(startMarkerIndex + CODE_BLOCK_START_MARKER.length, endMarkerIndex);
        }
        
        return relevantContent.trim().replace(/\r\n/g, '\n');
    };


    const parseCodeBlockHeader = (headerLine: string): ParsedHeader | null => {
        const quotedMatch = headerLine.match(/^"(.+?)"(?:\s+(.*))?$/);
        if (quotedMatch) {
            const filePath = quotedMatch[1]!;
            const strategyStr = (quotedMatch[2] || '').trim();
            if (strategyStr) {
                const parsedStrategy = PatchStrategySchema.safeParse(strategyStr);
                if (!parsedStrategy.success) {
                    return null;
                }
                return { filePath, patchStrategy: parsedStrategy.data };
            }
            return { filePath, patchStrategy: null };
        }

        const parts = headerLine.split(/\s+/);
        if (parts.length === 1 && parts[0]) {
            return { filePath: parts[0], patchStrategy: null };
        }
        if (parts.length === 2 && parts[0] && parts[1]) {
            const parsedStrategy = PatchStrategySchema.safeParse(parts[1]);
            if (parsedStrategy.success) {
                return { filePath: parts[0], patchStrategy: parsedStrategy.data };
            } else {
                return { filePath: headerLine, patchStrategy: null };
            }
        }

        if (parts.length > 2) {
            return null;
        }

        return null; // For empty or invalid header
    };


    const inferPatchStrategy = (content: string, providedStrategy: PatchStrategy
    | null): PatchStrategy => {
        if (providedStrategy) return providedStrategy;
        if (/^<<<<<<< SEARCH\s*$/m.test(content) && content.includes('>>>>>>> REPLACE')) return 'multi-search-replace';
        if (content.startsWith('--- ') && content.includes('+++ ') && content.includes('@@')) return 'new-unified';
        return 'replace';
    };


    const extractAndParseYaml = (rawText: string) => {
        // Strategy 1: Find all fenced YAML blocks and try to parse the last one.
        const yamlBlockMatches = [...rawText.matchAll(/```\s*(?:yaml|yml)[\r\n]([\s\S]+?)```/gi)];

        if (yamlBlockMatches.length > 0) {
            const lastMatch = yamlBlockMatches[yamlBlockMatches.length - 1]!;
            try {
                const yamlContent: unknown = yaml.load(lastMatch[1]!);
                const control = ControlYamlSchema.parse(yamlContent);
                // Success! This is our control block.
                const textWithoutYaml = rawText.substring(0, lastMatch.index) + rawText.substring(lastMatch.index! + lastMatch[0].length);
                return { control, textWithoutYaml: textWithoutYaml.trim() };
            } catch (e) {
                // The last block was not a valid control block.
                // We will now fall through to the non-fenced strategy, assuming the fenced block was just an example.
            }
        }

        // Strategy 2: Look for a non-fenced block at the end.
        const lines = rawText.trim().split('\n');
        let yamlStartIndex = -1;
        // Heuristic: project ID is required, so we look for that.
        const searchLimit = Math.max(0, lines.length - 20);
        for (let i = lines.length - 1; i >= searchLimit; i--) {
            if (lines[i]?.trim().match(/^projectId:/)) {
                yamlStartIndex = i;
                break;
            }
        }

        if (yamlStartIndex !== -1) {
            const yamlText = lines.slice(yamlStartIndex).join('\n');
            try {
                const yamlContent: unknown = yaml.load(yamlText);
                const control = ControlYamlSchema.parse(yamlContent);
                // Success!
                const textWithoutYaml = lines.slice(0, yamlStartIndex).join('\n');
                return { control, textWithoutYaml: textWithoutYaml.trim() };
            } catch (e) {
                // Non-fenced YAML block at the end was not a valid control block.
            }
        }
        
        // If both strategies fail, there's no valid control block.
        return { control: null, textWithoutYaml: rawText };
    };


    const parseCodeBlock = (match: RegExpExecArray): { operation: FileOperation,
    fullMatch: string } | null => {
        const [fullMatch, commentHeaderLine, spaceHeaderLine, rawContent] = match;
        const headerLine = (commentHeaderLine || spaceHeaderLine || '').trim();
        const content = (rawContent || '').trim();

        if (!headerLine) return null;

        if (headerLine === RENAME_FILE_OPERATION) {
            try {
                const { from, to } = z.object({ from: z.string().min(1), to: z.string().min(1) }).parse(JSON.parse(content));
                return { operation: { type: 'rename', from, to }, fullMatch };
            } catch (e) {
                return null;
            }
        }

        const parsedHeader = parseCodeBlockHeader(headerLine);
        if (!parsedHeader) {
            return null;
        }

        const { filePath } = parsedHeader;

        if (content === DELETE_FILE_MARKER) {
            return { operation: { type: 'delete', path: filePath }, fullMatch };
        }

        const patchStrategy = inferPatchStrategy(content, parsedHeader.patchStrategy);
        const cleanContent = extractCodeBetweenMarkers(content);

        return {
            operation: { type: 'write', path: filePath, content: cleanContent, patchStrategy }, 
            fullMatch
        };
    };


    export const parseLLMResponse = (rawText: string): ParsedLLMResponse | null
    => {
        const { control, textWithoutYaml } = extractAndParseYaml(rawText);

        if (!control) {
            return null;
        }

        const operations: FileOperation[] = [];
        const matchedBlocks: string[] = [];
        let match;

        while ((match = CODE_BLOCK_REGEX.exec(textWithoutYaml)) !== null) {
            const result = parseCodeBlock(match);
            if (result) {
                operations.push(result.operation);
                matchedBlocks.push(result.fullMatch);
            }
        }

        if (operations.length === 0) {
            return null;
        }

        let reasoningText = textWithoutYaml;
        for (const block of matchedBlocks) {
            reasoningText = reasoningText.replace(block, '');
        }
        const reasoning = reasoningText.split('\n').map(line => line.trim()).filter(Boolean);

        try {
            const parsedResponse = ParsedLLMResponseSchema.parse({ control, operations, reasoning });
            return parsedResponse;
        } catch (e) {
            return null;
        }
    };
  packages/relaycode-core/src/patch.ts: |-
    import { FileOperation } from './types';
    import { applyStandardDiff, applySearchReplace } from 'apply-multi-diff';

    const patchStrategies = {
      'new-unified': async (p: { originalContent: string; diffContent: string; }) => {
        const result = applyStandardDiff(p.originalContent, p.diffContent);
        if (result.success) return { success: true, content: result.content };
        return { success: false, error: result.error.message };
      },
      'multi-search-replace': async (p: { originalContent: string; diffContent: string; }) => {
        const result = applySearchReplace(p.originalContent, p.diffContent);
        if (result.success) return { success: true, content: result.content };
        return { success: false, error: result.error.message };
      },
      'unified': async (p: { originalContent: string; diffContent: string; }) => {
        const result = applyStandardDiff(p.originalContent, p.diffContent);
        if (result.success) return { success: true, content: result.content };
        return { success: false, error: result.error.message };
      },
    };

    export type ApplyOperationsResult = 
        | { success: true; newFileStates: Map<string, string | null> }
        | { success: false; error: string };

    export const applyOperations = async (
        operations: FileOperation[],
        originalFiles: Map<string, string | null>
    ): Promise<ApplyOperationsResult> => {
        const fileStates = new Map<string, string | null>(originalFiles);

        for (const op of operations) {
            if (op.type === 'delete') {
                fileStates.set(op.path, null);
                continue;
            }
            if (op.type === 'rename') {
                const content = fileStates.get(op.from);
                if (content === undefined) {
                    return { success: false, error: `Cannot rename non-existent or untracked file: ${op.from}` };
                }
                fileStates.set(op.from, null);
                fileStates.set(op.to, content);
                continue;
            }

            let finalContent: string;
            const currentContent = fileStates.get(op.path) ?? null;

            if (op.patchStrategy === 'replace') {
                finalContent = op.content;
            } else {
                if (currentContent === null && op.patchStrategy === 'multi-search-replace') {
                    return { success: false, error: `Cannot use 'multi-search-replace' on a new file: ${op.path}` };
                }

                try {
                    const diffParams = {
                        originalContent: currentContent ?? '',
                        diffContent: op.content,
                    };
                    
                    const patcher = patchStrategies[op.patchStrategy as keyof typeof patchStrategies];
                    if (!patcher) {
                        return { success: false, error: `Unknown patch strategy: '${op.patchStrategy}'` };
                    }
                    
                    const result = await patcher(diffParams);
                    if (result.success) {
                        if (typeof result.content !== 'string') {
                            return { success: false, error: `Patch for ${op.path} succeeded but returned no content.` };
                        }
                        finalContent = result.content;
                    } else {
                        return { success: false, error: `Patch failed for ${op.path}: ${result.error}` };
                    }
                } catch (e) {
                    const message = e instanceof Error ? e.message : String(e);
                    return { success: false, error: `Error applying patch for ${op.path} with strategy '${op.patchStrategy}': ${message}` };
                }
            }
            fileStates.set(op.path, finalContent);
        }

        return { success: true, newFileStates: fileStates };
    };

    const calculateLcsLength = (a: string[], b: string[]): number => {
        let s1 = a;
        let s2 = b;
        if (s1.length < s2.length) {
            [s1, s2] = [s2, s1];
        }
        const m = s1.length;
        const n = s2.length;
        
        const dp = Array(n + 1).fill(0);

        for (let i = 1; i <= m; i++) {
            let prev = 0;
            for (let j = 1; j <= n; j++) {
                const temp = dp[j];
                if (s1[i - 1] === s2[j - 1]) {
                    dp[j] = prev + 1;
                } else {
                    dp[j] = Math.max(dp[j], dp[j - 1]);
                }
                prev = temp;
            }
        }
        return dp[n];
    };

    export const calculateLineChanges = (
        op: FileOperation,
        originalFiles: Map<string, string | null>,
        newFiles: Map<string, string | null>
    ): { added: number; removed: number } => {
        if (op.type === 'rename') {
            return { added: 0, removed: 0 };
        }
        const oldContent = originalFiles.get(op.path) ?? null;

        if (op.type === 'delete') {
            const oldLines = oldContent ? oldContent.split('\n') : [];
            return { added: 0, removed: oldLines.length };
        }
        
        const newContent = newFiles.get(op.path) ?? null;

        if (oldContent === newContent) return { added: 0, removed: 0 };

        const oldLines = oldContent?.split('\n') ?? [];
        const newLines = newContent?.split('\n') ?? [];

        if (oldContent === null || oldContent === '') return { added: newLines.length, removed: 0 };
        if (newContent === null || newContent === '') return { added: 0, removed: oldLines.length };
        
        const lcsLength = calculateLcsLength(oldLines, newLines);
        return {
            added: newLines.length - lcsLength,
            removed: oldLines.length - lcsLength,
        };
    };
approved: true
