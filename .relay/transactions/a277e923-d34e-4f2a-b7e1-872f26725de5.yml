uuid: a277e923-d34e-4f2a-b7e1-872f26725de5
projectId: relaycode
createdAt: '2025-09-04T01:27:11.729Z'
linesAdded: 27
linesRemoved: 35
gitCommitMsg: 'refactor: remove new-unified and multi-search-replace aliases'
promptSummary: >-
  The user wants to refactor the codebase to remove the aliases 'new-unified'
  and 'multi-search-replace' and use the canonical names 'standard-diff' and
  'search-replace' from the 'apply-multi-diff' package. This is the first phase
  of the refactoring.
reasoning:
  - >-
    alright fam, let's get this refactor done. you're right, `apply-multi-diff`
    uses `standard-diff` and `search-replace`, so we'll ditch those custom
    aliases like `new-unified` and `multi-search-replace` throughout the
    codebase. this will make things way more consistent and easier to
    understand.
  - >-
    here's phase one. we're gonna update the types, parser, user-facing prompts,
    and tests to use the canonical strategy names.
  - '### 1. Update Core Types'
  - >-
    first up, let's fix the `WatcherConfigSchema` in our core types to use the
    correct strategy names.
  - '### 2. Simplify the Parser'
  - >-
    next, we'll remove the `mapStrategyAlias` function from the parser. no need
    for it if we're using the right names everywhere else. this simplifies the
    logic.
  - '### 3. Update User-Facing Messages'
  - >-
    can't have our CLI giving out old info. let's update the `init` command's
    help text.
  - >-
    and more importantly, the system prompt generated by the `watch` command.
    this is what the AI sees, so it's gotta be accurate.
  - '### 4. Update E2E Tests'
  - gotta keep the tests green. updating the fixtures to use `standard-diff`.
  - and finally, the transaction test file itself.
  - >-
    that's it for phase one. we're now consistently using the real strategy
    names. hit me with phase two when you're ready.
operations:
  - type: write
    path: packages/relaycode-core/src/types.ts
    content: >-
      --- packages/relaycode-core/src/types.ts

      +++ packages/relaycode-core/src/types.ts

      @@ -14,7 +14,7 @@
       
       const WatcherConfigSchema = z.object({
         clipboardPollInterval: z.number().int().positive().default(2000),
      -  preferredStrategy: z.enum(['auto', 'replace', 'new-unified',
      'multi-search-replace']).default('auto'),

      +  preferredStrategy: z.enum(['auto', 'replace', 'standard-diff',
      'search-replace']).default('auto'),
       });
       
       const PatchConfigSchema = z.object({
    patchStrategy: new-unified
  - type: write
    path: packages/relaycode-core/src/parser.ts
    content: >-
      --- packages/relaycode-core/src/parser.ts

      +++ packages/relaycode-core/src/parser.ts

      @@ -10,12 +10,6 @@
       
       const CODE_BLOCK_REGEX = /```(?:\w+)?\s*([^\r\n]*?)\r?\n([\s\S]*?)```/g;
       
      -const mapStrategyAlias = (strategy: string): string => {

      -  if (strategy === 'new-unified') return 'standard-diff';

      -  if (strategy === 'multi-search-replace') return 'search-replace';

      -  return strategy;

      -};

      -
       type ParsedHeader = {
         filePath: string;
         patchStrategy: PatchStrategy | null;
      @@ -32,8 +26,7 @@
           const parts = headerLine.split(/\s+/);
           if (parts.length > 1) {
             const lastPart = parts[parts.length - 1]!;
      -      const mappedStrategy = mapStrategyAlias(lastPart);

      -      const parsedStrategy =
      PatchStrategySchema.safeParse(mappedStrategy);

      +      const parsedStrategy = PatchStrategySchema.safeParse(lastPart);
             if (parsedStrategy.success) {
               const filePath = parts.slice(0, -1).join(' ');
               return { filePath, patchStrategy: parsedStrategy.data };
      @@ -47,8 +40,7 @@
         if (!filePath) return null;
       
         const strategyStr = match[3] || '';
      -  const mappedStrategy = mapStrategyAlias(strategyStr);

      -  const parsedStrategy = PatchStrategySchema.safeParse(mappedStrategy);

      +  const parsedStrategy = PatchStrategySchema.safeParse(strategyStr);
       
         return { filePath, patchStrategy: parsedStrategy.success ? parsedStrategy.data : null };
       };
    patchStrategy: new-unified
  - type: write
    path: src/commands/init.ts
    content: >-
      --- src/commands/init.ts

      +++ src/commands/init.ts

      @@ -10,7 +10,7 @@
       
       ${chalk.bold('Next steps:')}
       ${chalk.gray('1.')} (Optional) Open ${chalk.cyan(CONFIG_FILE_NAME_JSON)} to customize settings. The config is organized into sections:
      -   - In ${chalk.yellow("'watcher'")}, you can set
      ${chalk.yellow("'preferredStrategy'")} to control AI patch generation
      ('auto', 'new-unified', 'multi-search-replace', etc.).

      +   - In ${chalk.yellow("'watcher'")}, you can set
      ${chalk.yellow("'preferredStrategy'")} to control AI patch generation
      ('auto', 'standard-diff', 'search-replace', etc.).
          - In ${chalk.yellow("'git'")}, you can enable ${chalk.yellow("'git.autoGitBranch'")} to create a new branch for each transaction.
          - In ${chalk.yellow("'patch'")}, you can configure the linter, pre/post commands, and approval behavior.
    patchStrategy: new-unified
  - type: write
    path: src/commands/watch.ts
    content: >-
      --- src/commands/watch.ts

      +++ src/commands/watch.ts

      @@ -18,25 +18,25 @@
       \`\`\`typescript // filePath {patchStrategy}
       ... content ...
       \`\`\`
       - \`filePath\`: The path to the file. **If the path contains spaces, it MUST be enclosed in double quotes.**
      -- \`patchStrategy\`: (Optional) One of \`new-unified\`,
      \`multi-search-replace\`. If omitted, the entire file is replaced (this is
      the \`replace\` strategy).

      +- \`patchStrategy\`: (Optional) One of \`standard-diff\`,
      \`search-replace\`. If omitted, the entire file is replaced (this is the
      \`replace\` strategy).
       
       **Examples:**
       \`\`\`typescript // src/components/Button.tsx
       ...
       \`\`\`
      -\`\`\`typescript // "src/components/My Component.tsx" new-unified

      +\`\`\`typescript // "src/components/My Component.tsx" standard-diff
       ...
       \`\`\``;
       
           const syntaxReplace = `
       **Syntax:**
       \`\`\`typescript // filePath
       ... content ...
       \`\`\`
       - \`filePath\`: The path to the file. **If the path contains spaces, it MUST be enclosed in double quotes.**
       - Only the \`replace\` strategy is enabled. This means you must provide the ENTIRE file content for any change. This is suitable for creating new files or making changes to small files.`;
       
      -    const syntaxNewUnified = `

      +    const syntaxStandardDiff = `
       **Syntax:**
      -\`\`\`typescript // filePath new-unified

      +\`\`\`typescript // filePath standard-diff
       ... diff content ...
       \`\`\`
       - \`filePath\`: The path to the file. **If the path contains spaces, it MUST be enclosed in double quotes.**
      -- You must use the \`new-unified\` patch strategy for all
      modifications.`;

      +- You must use the \`standard-diff\` patch strategy for all
      modifications.`;
       
      -    const syntaxMultiSearchReplace = `

      +    const syntaxSearchReplace = `
       **Syntax:**
      -\`\`\`typescript // filePath multi-search-replace

      +\`\`\`typescript // filePath search-replace
       ... diff content ...
       \`\`\`
       - \`filePath\`: The path to the file. **If the path contains spaces, it MUST be enclosed in double quotes.**
      -- You must use the \`multi-search-replace\` patch strategy for all
      modifications.`;

      +- You must use the \`search-replace\` patch strategy for all
      modifications.`;
       
      -    const sectionNewUnified = `---

      +    const sectionStandardDiff = `---
       
      -### Strategy 1: Advanced Unified Diff (\`new-unified\`) - RECOMMENDED

      +### Strategy 1: Advanced Unified Diff (\`standard-diff\`) - RECOMMENDED
       
       Use for most changes, like refactoring, adding features, and fixing bugs. It's resilient to minor changes in the source file.
       
      @@ -82,11 +82,11 @@
       \`\`\`
       `;
       
      -    const sectionMultiSearchReplace = `---

      +    const sectionSearchReplace = `---
       
      -### Strategy 2: Multi-Search-Replace (\`multi-search-replace\`)

      +### Strategy 2: Search-Replace (\`search-replace\`)
       
       Use for precise, surgical replacements. The \`SEARCH\` block must be an exact match of the content in the file.
       
      @@ -155,11 +155,11 @@
           const footer = `---------------------------------------------------------------------------`;
       
           const strategyInfo = {
      -        auto: { syntax: syntaxAuto, details:
      `${sectionNewUnified}\n${sectionMultiSearchReplace}` },

      +        auto: { syntax: syntaxAuto, details:
      `${sectionStandardDiff}\n${sectionSearchReplace}` },
               replace: { syntax: syntaxReplace, details: '' },
      -        'new-unified': { syntax: syntaxNewUnified, details:
      sectionNewUnified },

      -        'multi-search-replace': { syntax: syntaxMultiSearchReplace,
      details: sectionMultiSearchReplace },

      +        'standard-diff': { syntax: syntaxStandardDiff, details:
      sectionStandardDiff },

      +        'search-replace': { syntax: syntaxSearchReplace, details:
      sectionSearchReplace },
           };
       
           const preferred = strategyInfo[preferredStrategy] ?? strategyInfo.auto;
    patchStrategy: new-unified
  - type: write
    path: test/fixtures/e2e/complex-scenarios.yml
    content: |-
      <<<<<<< SEARCH
            Next, I'll edit the main entrypoint to use this config.
            ```diff // src/main.ts new-unified
            --- src/main.ts
            +++ src/main.ts
      =======
            Next, I'll edit the main entrypoint to use this config.
            ```diff // src/main.ts standard-diff
            --- src/main.ts
            +++ src/main.ts
      >>>>>>> REPLACE
    patchStrategy: multi-search-replace
  - type: write
    path: test/fixtures/e2e/edge-cases.yml
    content: |-
      <<<<<<< SEARCH
          description: Should correctly edit a file that has spaces in its path
          markdown_content: |
            ```diff // "src/components/My Component.tsx" new-unified
            --- "src/components/My Component.tsx"
            +++ "src/components/My Component.tsx"
      =======
          description: Should correctly edit a file that has spaces in its path
          markdown_content: |
            ```diff // "src/components/My Component.tsx" standard-diff
            --- "src/components/My Component.tsx"
            +++ "src/components/My Component.tsx"
      >>>>>>> REPLACE
      <<<<<<< SEARCH
            Now, add a method to it.
            ```diff // src/service.ts new-unified
            --- src/service.ts
            +++ src/service.ts
      =======
            Now, add a method to it.
            ```diff // src/service.ts standard-diff
            --- src/service.ts
            +++ src/service.ts
      >>>>>>> REPLACE
    patchStrategy: multi-search-replace
  - type: write
    path: test/fixtures/e2e/success.yml
    content: |-
      <<<<<<< SEARCH
        - name: apply-new-unified-diff
          description: Should correctly apply a patch using the new-unified strategy
          markdown_content: |
            ```diff // src/app.js new-unified
            --- src/app.js
            +++ src/app.js
      =======
        - name: apply-standard-diff-alias
          description: Should correctly apply a patch using the standard-diff strategy (from former new-unified alias)
          markdown_content: |
            ```diff // src/app.js standard-diff
            --- src/app.js
            +++ src/app.js
      >>>>>>> REPLACE
    patchStrategy: multi-search-replace
  - type: write
    path: test/e2e/transaction.test.ts
    content: >-
      --- test/e2e/transaction.test.ts

      +++ test/e2e/transaction.test.ts

      @@ -404,8 +404,8 @@
             context,
             {},
             [
      -        { type: 'edit', path: originalFilePath, content: unifiedDiff,
      strategy: 'new-unified' },

      -        { type: 'edit', path: originalFilePath, content:
      searchReplaceDiff, strategy: 'multi-search-replace' },

      +        { type: 'edit', path: originalFilePath, content: unifiedDiff,
      strategy: 'standard-diff' },

      +        { type: 'edit', path: originalFilePath, content:
      searchReplaceDiff, strategy: 'search-replace' },
               { type: 'rename', from: originalFilePath, to: renamedFilePath },
             ]
           );
    patchStrategy: new-unified
snapshot:
  packages/relaycode-core/src/types.ts: >-
    import { z } from 'zod';


    export const LogLevelNameSchema = z.enum(['silent', 'error', 'warn', 'info',
    'debug']).default('info');

    export type LogLevelName = z.infer<typeof LogLevelNameSchema>;


    // Schema for relaycode.config.json

    const CoreConfigSchema = z.object({
      logLevel: LogLevelNameSchema,
      enableNotifications: z.boolean().default(true),
      watchConfig: z.boolean().default(true),
    });


    const WatcherConfigSchema = z.object({
      clipboardPollInterval: z.number().int().positive().default(2000),
      preferredStrategy: z.enum(['auto', 'replace', 'new-unified', 'multi-search-replace']).default('auto'),
    });


    const PatchConfigSchema = z.object({
      approvalMode: z.enum(['auto', 'manual']).default('auto'),
      approvalOnErrorCount: z.number().int().min(0).default(0),
      linter: z.string().default('bun tsc --noEmit'),
      preCommand: z.string().default(''),
      postCommand: z.string().default(''),
      minFileChanges: z.number().int().min(0).default(0),
      maxFileChanges: z.number().int().min(1).optional(),
    });


    const GitConfigSchema = z.object({
      autoGitBranch: z.boolean().default(false),
      gitBranchPrefix: z.string().default('relay/'),
      gitBranchTemplate: z.enum(['uuid', 'gitCommitMsg']).default('gitCommitMsg'),
    });


    const BaseConfigSchema = z.object({
      projectId: z.string().min(1),
      core: CoreConfigSchema,
      watcher: WatcherConfigSchema,
      patch: PatchConfigSchema,
      git: GitConfigSchema,
    });


    export const ConfigSchema = BaseConfigSchema.deepPartial().extend({
      projectId: z.string().min(1),
    }).transform(val => ({
      projectId: val.projectId,
      core: CoreConfigSchema.parse(val.core ?? {}),
      watcher: WatcherConfigSchema.parse(val.watcher ?? {}),
      patch: PatchConfigSchema.parse(val.patch ?? {}),
      git: GitConfigSchema.parse(val.git ?? {}),
    }));

    export type Config = z.infer<typeof ConfigSchema>;


    export type RelayCodeConfigInput = z.input<typeof ConfigSchema>;

    export const defineConfig = (config: RelayCodeConfigInput):
    RelayCodeConfigInput => config;


    export const PatchStrategySchema = z.enum([
      'replace',
      'standard-diff',
      'search-replace',
    ]).default('replace');

    export type PatchStrategy = z.infer<typeof PatchStrategySchema>;


    export const FileSnapshotSchema = z.record(z.string(),
    z.string().nullable());

    export type FileSnapshot = z.infer<typeof FileSnapshotSchema>;


    // Schema for operations parsed from code blocks

    export const FileOperationSchema = z.union([
      z.object({
        type: z.literal('write'),
        path: z.string(),
        content: z.string(),
        patchStrategy: PatchStrategySchema,
      }),
      z.object({
        type: z.literal('delete'),
        path: z.string(),
      }),
      z.object({
        type: z.literal('rename'),
        from: z.string(),
        to: z.string(),
      }),
    ]);

    export type FileOperation = z.infer<typeof FileOperationSchema>;


    // Schema for the state file (transaction record)

    export const StateFileSchema = z.object({
      uuid: z.string().uuid(),
      projectId: z.string(),
      createdAt: z.string(), // ISO string
      linesAdded: z.number().optional(),
      linesRemoved: z.number().optional(),
      gitCommitMsg: z.string().optional(),
      promptSummary: z.string().optional(),
      reasoning: z.array(z.string()),
      operations: z.array(FileOperationSchema),
      snapshot: FileSnapshotSchema,
      approved: z.boolean(),
    });

    export type StateFile = z.infer<typeof StateFileSchema>;


    // Schema for the control YAML block at the end of the LLM response

    export const ControlYamlSchema = z.object({
      projectId: z.string(),
      uuid: z.string().uuid(),
      changeSummary: z.array(z.record(z.string(), z.string())).optional(), // Not strictly used, but good to parse
      gitCommitMsg: z.string().optional(),
      promptSummary: z.string().optional(),
    });

    export type ControlYaml = z.infer<typeof ControlYamlSchema>;


    // The fully parsed response from the clipboard

    export const ParsedLLMResponseSchema = z.object({
      control: ControlYamlSchema,
      operations: z.array(FileOperationSchema),
      reasoning: z.array(z.string()),
    });

    export type ParsedLLMResponse = z.infer<typeof ParsedLLMResponseSchema>;
  packages/relaycode-core/src/parser.ts: >
    import yaml from 'js-yaml';

    import { logger } from './logger';

    import { z } from 'zod';

    import {
      ControlYamlSchema,
      FileOperation,
      ParsedLLMResponse,
      ParsedLLMResponseSchema,
      PatchStrategy,
      PatchStrategySchema,
    } from './types';

    import {
      DELETE_FILE_MARKER,
      RENAME_FILE_OPERATION
    } from './constants';


    const CODE_BLOCK_REGEX = /```(?:\w+)?\s*([^\r\n]*?)\r?\n([\s\S]*?)```/g;


    const mapStrategyAlias = (strategy: string): string => {
      if (strategy === 'new-unified') return 'standard-diff';
      if (strategy === 'multi-search-replace') return 'search-replace';
      return strategy;
    };


    type ParsedHeader = {
      filePath: string;
      patchStrategy: PatchStrategy | null;
    };


    const parseCodeBlockHeader = (headerLine: string): ParsedHeader | null => {
      // This regex handles:
      // 1. A quoted file path, optionally followed by a strategy.
      // 2. An unquoted file path, optionally followed by a strategy.
      // It's more robust than splitting by space.
      const match = headerLine.match(/^(?:"([^"]+)"|(\S+))(?:\s+(\S+))?$/);

      if (!match) {
        // If the regex fails, it might be a path with spaces that isn't quoted.
        // The instructions say paths with spaces MUST be quoted, but we can be lenient.
        // We'll check if the last word is a strategy. If so, the rest is the path.
        const parts = headerLine.split(/\s+/);
        if (parts.length > 1) {
          const lastPart = parts[parts.length - 1]!;
          const mappedStrategy = mapStrategyAlias(lastPart);
          const parsedStrategy = PatchStrategySchema.safeParse(mappedStrategy);
          if (parsedStrategy.success) {
            const filePath = parts.slice(0, -1).join(' ');
            return { filePath, patchStrategy: parsedStrategy.data };
          }
        }
        // Otherwise, assume the whole line is a file path with no strategy.
        return headerLine.trim() ? { filePath: headerLine.trim(), patchStrategy: null } : null;
      }

      const filePath = match[1] || match[2]; // Group 1 is quoted, group 2 is unquoted.
      if (!filePath) return null;

      const strategyStr = match[3] || '';
      const mappedStrategy = mapStrategyAlias(strategyStr);
      const parsedStrategy = PatchStrategySchema.safeParse(mappedStrategy);

      return { filePath, patchStrategy: parsedStrategy.success ? parsedStrategy.data : null };
    };


    const inferPatchStrategy = (content: string, providedStrategy: PatchStrategy
    | null): PatchStrategy => {
      if (providedStrategy) return providedStrategy;
      if (/^<<<<<<< SEARCH\s*$/m.test(content) && content.includes('>>>>>>> REPLACE')) return 'search-replace';
      if (content.startsWith('--- ') && content.includes('+++ ') && content.includes('@@')) return 'standard-diff';
      return 'replace';
    };


    const extractAndParseYaml = (rawText: string) => {
      // Strategy 1: Find all fenced YAML blocks and try to parse the last one.
      const yamlBlockMatches = [...rawText.matchAll(/```\s*(?:yaml|yml)[\r\n]([\s\S]+?)```/gi)];

      if (yamlBlockMatches.length > 0) {
        const lastMatch = yamlBlockMatches[yamlBlockMatches.length - 1]!;
        try {
          const yamlContent: unknown = yaml.load(lastMatch[1]!);
          const control = ControlYamlSchema.parse(yamlContent);
          // Success! This is our control block.
          const textWithoutYaml = rawText.substring(0, lastMatch.index) + rawText.substring(lastMatch.index! + lastMatch[0].length);
          return { control, textWithoutYaml: textWithoutYaml.trim() };
        } catch (e) {
          // The last block was not a valid control block.
          // We will now fall through to the non-fenced strategy, assuming the fenced block was just an example.
        }
      }

      // Strategy 2: Look for a non-fenced block at the end.
      const lines = rawText.trim().split('\n');
      let yamlStartIndex = -1;
      // Heuristic: project ID is required, so we look for that.
      const searchLimit = Math.max(0, lines.length - 20);
      for (let i = lines.length - 1; i >= searchLimit; i--) {
        if (lines[i]?.trim().match(/^projectId:/)) {
          yamlStartIndex = i;
          break;
        }
      }

      if (yamlStartIndex !== -1) {
        const yamlText = lines.slice(yamlStartIndex).join('\n');
        try {
          const yamlContent: unknown = yaml.load(yamlText);
          const control = ControlYamlSchema.parse(yamlContent);
          // Success!
          const textWithoutYaml = lines.slice(0, yamlStartIndex).join('\n');
          return { control, textWithoutYaml: textWithoutYaml.trim() };
        } catch (e) {
          // Non-fenced YAML block at the end was not a valid control block.
        }
      }

      // If both strategies fail, there's no valid control block.
      return { control: null, textWithoutYaml: rawText };
    };


    const parseCodeBlock = (match: RegExpExecArray): { operation: FileOperation,
    fullMatch: string } | null => {
      const [fullMatch, rawHeader, rawContent] = match;
      let headerLine = (rawHeader || '').trim();

      // CRITICAL FIX: Do not strip the trailing newline. Preserve the raw content from the regex.
      const content = rawContent || '';

      logger.debug(`[parser] Matched block header: '${rawHeader}'`);
      logger.debug(`[parser] Raw content (JSON encoded):`, JSON.stringify(content));

      const commentIndex = headerLine.indexOf('//');
      if (commentIndex !== -1) {
        // If we find `//`, we assume what follows is the file path and optional strategy.
        // This handles `typescript // "path/to/my component.ts" new-unified`.
        headerLine = headerLine.substring(commentIndex + 2).trim();
      }

      if (headerLine.startsWith('//')) {
        headerLine = headerLine.substring(2).trim();
      }

      if (!headerLine) return null;

      if (headerLine === RENAME_FILE_OPERATION) {
        try {
          const { from, to } = z.object({ from: z.string().min(1), to: z.string().min(1) }).parse(JSON.parse(content));
          return { operation: { type: 'rename', from, to }, fullMatch };
        } catch (e) {
          return null;
        }
      }

      const parsedHeader = parseCodeBlockHeader(headerLine);
      if (!parsedHeader) {
        return null;
      }

      const { filePath } = parsedHeader;

      if (content.trim() === DELETE_FILE_MARKER) {
        return { operation: { type: 'delete', path: filePath }, fullMatch };
      }

      const patchStrategy = inferPatchStrategy(content, parsedHeader.patchStrategy);

      // CRITICAL FIX: No more START/END marker logic.
      // For 'replace' strategy, we only clean up a potential single leading newline,
      // which can be an artifact of markdown formatting. All other content is preserved.
      const cleanContent = (patchStrategy === 'replace')
        ? content.replace(/^\r?\n/, '')
        : content;

      if (patchStrategy === 'replace') {
        logger.debug(`[parser] Final 'replace' content (JSON encoded):`, JSON.stringify(cleanContent));
      }

      return {
        operation: { type: 'write', path: filePath, content: cleanContent, patchStrategy },
        fullMatch
      };
    };


    export const parseLLMResponse = (rawText: string): ParsedLLMResponse | null
    => {
      const { control, textWithoutYaml } = extractAndParseYaml(rawText);

      if (!control) {
        return null;
      }

      const operations: FileOperation[] = [];
      const matchedBlocks: string[] = [];
      let match;

      while ((match = CODE_BLOCK_REGEX.exec(textWithoutYaml)) !== null) {
        const result = parseCodeBlock(match);
        if (result) {
          operations.push(result.operation);
          matchedBlocks.push(result.fullMatch);
        }
      }

      if (operations.length === 0) {
        return null;
      }

      let reasoningText = textWithoutYaml;
      for (const block of matchedBlocks) {
        reasoningText = reasoningText.replace(block, '');
      }
      const reasoning = reasoningText.split('\n').map(line => line.trim()).filter(Boolean);

      try {
        const parsedResponse = ParsedLLMResponseSchema.parse({ control, operations, reasoning });
        return parsedResponse;
      } catch (e) {
        return null;
      }
    };
  src/commands/init.ts: >-
    import { promises as fs } from 'fs';

    import path from 'path';

    import { findConfig, createConfig, getProjectId, getStateDirectory } from
    '../core/config';

    import { logger, getErrorMessage, isEnoentError } from '../utils/logger';

    import { STATE_DIRECTORY_NAME, GITIGNORE_FILE_NAME, GITIGNORE_COMMENT,
    CONFIG_FILE_NAME_JSON } from '../utils/constants';

    import chalk from 'chalk';


    const getInitMessage = (projectId: string): string => `

    ${chalk.green('✅ relaycode has been initialized for this project.')}


    Configuration file created: ${chalk.cyan(CONFIG_FILE_NAME_JSON)}


    Project ID: ${chalk.cyan(projectId)}


    ${chalk.bold('Next steps:')}

    ${chalk.gray('1.')} (Optional) Open ${chalk.cyan(CONFIG_FILE_NAME_JSON)} to
    customize settings. The config is organized into sections:
       - In ${chalk.yellow("'watcher'")}, you can set ${chalk.yellow("'preferredStrategy'")} to control AI patch generation ('auto', 'new-unified', 'multi-search-replace', etc.).
       - In ${chalk.yellow("'git'")}, you can enable ${chalk.yellow("'git.autoGitBranch'")} to create a new branch for each transaction.
       - In ${chalk.yellow("'patch'")}, you can configure the linter, pre/post commands, and approval behavior.

    ${chalk.gray('2.')} Run ${chalk.magenta("'relay watch'")} in your terminal.
    This will start the service and display the system prompt tailored to your
    configuration.


    ${chalk.gray('3.')} Copy the system prompt provided by
    ${chalk.magenta("'relay watch'")} and paste it into your AI assistant's
    "System Prompt" or "Custom Instructions".

    `;



    const updateGitignore = async (cwd: string): Promise<void> => {
        const gitignorePath = path.join(cwd, GITIGNORE_FILE_NAME);
        const entry = `\n${GITIGNORE_COMMENT}\n/${STATE_DIRECTORY_NAME}/\n`;

        try {
            let content = await fs.readFile(gitignorePath, 'utf-8');
            if (!content.includes(STATE_DIRECTORY_NAME)) {
                content += entry;
                await fs.writeFile(gitignorePath, content);
                logger.info(`Updated ${chalk.cyan(GITIGNORE_FILE_NAME)} to ignore ${chalk.cyan(STATE_DIRECTORY_NAME)}/`);
            }
        } catch (error) {
            if (isEnoentError(error)) {
                await fs.writeFile(gitignorePath, entry.trim());
                logger.info(`Created ${chalk.cyan(GITIGNORE_FILE_NAME)} and added ${chalk.cyan(STATE_DIRECTORY_NAME)}/`);
            } else {
                logger.error(`Failed to update ${chalk.cyan(GITIGNORE_FILE_NAME)}: ${getErrorMessage(error)}`);
            }
        }
    };


    export const initCommand = async (cwd: string = process.cwd()):
    Promise<void> => {
        logger.info('Initializing relaycode in this project...');

        const config = await findConfig(cwd);
        if (config) {
            logger.warn(`Configuration file already exists. Initialization skipped.`);
            logger.log(`
    To use relaycode, please run ${chalk.magenta("'relay watch'")}.

    It will display a system prompt to copy into your LLM assistant.

    You can review your configuration in your existing config file.

    `);
            return;
        }
        
        const projectId = await getProjectId(cwd);
        await createConfig(projectId, cwd);
        logger.success(`Created configuration file: ${chalk.cyan(CONFIG_FILE_NAME_JSON)}`);
        
        // Explicitly create the db directory so `log` command doesn't fail on a fresh init
        await fs.mkdir(path.join(getStateDirectory(cwd), 'db'), { recursive: true });
        logger.success(`Created state directory: ${STATE_DIRECTORY_NAME}/`);

        await updateGitignore(cwd);

        logger.log(getInitMessage(projectId));
    };
  src/commands/watch.ts: >-
    import { findConfig, loadConfigOrExit, findConfigPath } from
    '../core/config';

    import { createClipboardWatcher } from '../core/clipboard';

    import { parseLLMResponse } from 'relaycode-core';

    import { processPatch } from '../core/transaction';

    import { logger } from '../utils/logger';

    import { Config } from 'relaycode-core';

    import fs from 'fs';

    import path from 'path';


    const getSystemPrompt = (
        projectId: string,
        preferredStrategy: Config['watcher']['preferredStrategy'],
        patchConfig: Config['patch'],
    ): string => {
        const header = `
    ✅ relaycode is watching for changes.


    IMPORTANT: For relaycode to work, you must configure your AI assistant.

    Copy the entire text below and paste it into your LLM's "System Prompt"

    or "Custom Instructions" section.

    ---------------------------------------------------------------------------`;

        const intro = `You are an expert AI programmer. To modify a file, you MUST use a code block with a specified patch strategy.`;

        const syntaxAuto = `
    **Syntax:**

    \`\`\`typescript // filePath {patchStrategy}

    ... content ...

    \`\`\`

    - \`filePath\`: The path to the file. **If the path contains spaces, it MUST
    be enclosed in double quotes.**

    - \`patchStrategy\`: (Optional) One of \`new-unified\`,
    \`multi-search-replace\`. If omitted, the entire file is replaced (this is
    the \`replace\` strategy).


    **Examples:**

    \`\`\`typescript // src/components/Button.tsx

    ...

    \`\`\`

    \`\`\`typescript // "src/components/My Component.tsx" new-unified

    ...

    \`\`\``;

        const syntaxReplace = `
    **Syntax:**

    \`\`\`typescript // filePath

    ... content ...

    \`\`\`

    - \`filePath\`: The path to the file. **If the path contains spaces, it MUST
    be enclosed in double quotes.**

    - Only the \`replace\` strategy is enabled. This means you must provide the
    ENTIRE file content for any change. This is suitable for creating new files
    or making changes to small files.`;

        const syntaxNewUnified = `
    **Syntax:**

    \`\`\`typescript // filePath new-unified

    ... diff content ...

    \`\`\`

    - \`filePath\`: The path to the file. **If the path contains spaces, it MUST
    be enclosed in double quotes.**

    - You must use the \`new-unified\` patch strategy for all modifications.`;

        const syntaxMultiSearchReplace = `
    **Syntax:**

    \`\`\`typescript // filePath multi-search-replace

    ... diff content ...

    \`\`\`

    - \`filePath\`: The path to the file. **If the path contains spaces, it MUST
    be enclosed in double quotes.**

    - You must use the \`multi-search-replace\` patch strategy for all
    modifications.`;

        const sectionNewUnified = `---

    ### Strategy 1: Advanced Unified Diff (\`new-unified\`) - RECOMMENDED


    Use for most changes, like refactoring, adding features, and fixing bugs.
    It's resilient to minor changes in the source file.


    **Diff Format:**

    1.  **File Headers**: Start with \`--- {filePath}\` and \`+++ {filePath}\`.

    2.  **Hunk Header**: Use \`@@ ... @@\`. Exact line numbers are not needed.

    3.  **Context Lines**: Include 2-3 unchanged lines before and after your
    change for context.

    4.  **Changes**: Mark additions with \`+\` and removals with \`-\`. Maintain
    indentation.


    **Example:**

    \`\`\`diff

    --- src/utils.ts

    +++ src/utils.ts

    @@ ... @@
        function calculateTotal(items: number[]): number {
    -      return items.reduce((sum, item) => {

    -        return sum + item;

    -      }, 0);

    +      const total = items.reduce((sum, item) => {

    +        return sum + item * 1.1;  // Add 10% markup

    +      }, 0);

    +      return Math.round(total * 100) / 100;  // Round to 2 decimal places

    +    }

    \`\`\`

    `;

        const sectionMultiSearchReplace = `---

    ### Strategy 2: Multi-Search-Replace (\`multi-search-replace\`)


    Use for precise, surgical replacements. The \`SEARCH\` block must be an
    exact match of the content in the file.


    **Diff Format:**

    Repeat this block for each replacement.

    \`\`\`diff

    <<<<<<< SEARCH

    [exact content to find including whitespace]

    =======

    [new content to replace with]

    >>>>>>> REPLACE

    \`\`\`

    `;

        const otherOps = `---

    ### Other Operations


    -   **Creating a file**: Use the default \`replace\` strategy (omit the
    strategy name) and provide the full file content.

    -   **Deleting a file**:
        \`\`\`typescript // path/to/file.ts
        //TODO: delete this file
        \`\`\`
        \`\`\`typescript // "path/to/My Old Component.ts"
        //TODO: delete this file
        \`\`\`
    -   **Renaming/Moving a file**:
        \`\`\`json // rename-file
        {
          "from": "src/old/path/to/file.ts",
          "to": "src/new/path/to/file.ts"
        }
        \`\`\`
    `;

        const finalSteps_rules = [];
        if (patchConfig.minFileChanges > 0) {
            finalSteps_rules.push(`You must modify at least ${patchConfig.minFileChanges} file(s) in this transaction.`);
        }
        if (patchConfig.maxFileChanges) {
            finalSteps_rules.push(`You must not modify more than ${patchConfig.maxFileChanges} file(s) in this transaction.`);
        }

        const finalSteps_list = [
            'Add your step-by-step reasoning in plain text before each code block.',
        ];
        if (finalSteps_rules.length > 0) {
            finalSteps_list.push(`Adhere to file limits: ${finalSteps_rules.join(' ')}`);
        }
        finalSteps_list.push('ALWAYS add the following YAML block at the very end of your response. Use the exact projectId shown here. Generate a new random uuid for each response.');

        const finalSteps_list_string = finalSteps_list.map((item, index) => `${index + 1}.  ${item}`).join('\n');

        const finalSteps = `---

    ### Final Steps


    ${finalSteps_list_string}

        \`\`\`yaml
        projectId: ${projectId}
        uuid: (generate a random uuid)
        changeSummary:
          - edit: src/main.ts
          - new: src/components/Button.tsx
          - delete: src/utils/old-helper.ts
        promptSummary: "A brief summary of my request."
        gitCommitMsg: "feat: A concise, imperative git commit message."
        \`\`\`
    `;
        
        const footer = `---------------------------------------------------------------------------`;

        const strategyInfo = {
            auto: { syntax: syntaxAuto, details: `${sectionNewUnified}\n${sectionMultiSearchReplace}` },
            replace: { syntax: syntaxReplace, details: '' },
            'new-unified': { syntax: syntaxNewUnified, details: sectionNewUnified },
            'multi-search-replace': { syntax: syntaxMultiSearchReplace, details: sectionMultiSearchReplace },
        };

        const preferred = strategyInfo[preferredStrategy] ?? strategyInfo.auto;
        const syntax = preferred.syntax;
        const strategyDetails = preferred.details;

        return [header, intro, syntax, strategyDetails, otherOps, finalSteps, footer].filter(Boolean).join('\n');
    };


    export const watchCommand = async (options: { yes?: boolean } = {}, cwd:
    string = process.cwd()): Promise<{ stop: () => void }> => {
      let clipboardWatcher: ReturnType<typeof createClipboardWatcher> | null = null;
      let configWatcher: fs.FSWatcher | null = null;
      let debounceTimer: NodeJS.Timeout | null = null;

      const startServices = (config: Config) => {
        // Stop existing watcher if it's running
        if (clipboardWatcher) {
          clipboardWatcher.stop();
        }

        logger.setLevel(config.core.logLevel);
        logger.debug(`Log level set to: ${config.core.logLevel}`);
        logger.debug(`Preferred strategy set to: ${config.watcher.preferredStrategy}`);

        logger.log(getSystemPrompt(config.projectId, config.watcher.preferredStrategy, config.patch));

        clipboardWatcher = createClipboardWatcher(config.watcher.clipboardPollInterval, async (content) => {
          logger.info('New clipboard content detected. Attempting to parse...');
          const parsedResponse = parseLLMResponse(content);

          if (!parsedResponse) {
            logger.warn('Clipboard content is not a valid relaycode patch. Ignoring.');
            return;
          }

          // Check project ID before notifying and processing.
          if (parsedResponse.control.projectId !== config.projectId) {
            logger.debug(`Ignoring patch for different project (expected '${config.projectId}', got '${parsedResponse.control.projectId}').`);
            return;
          }

          await processPatch(config, parsedResponse, { cwd, notifyOnStart: true, yes: options.yes });
          logger.info('--------------------------------------------------');
          logger.info('Watching for next patch...');
        });
      };

      const handleConfigChange = () => {
        if (debounceTimer) clearTimeout(debounceTimer);
        debounceTimer = setTimeout(async () => {
          logger.info(`Configuration file change detected. Reloading...`);
          try {
            const newConfig = await findConfig(cwd);
            if (newConfig) {
              logger.success('Configuration reloaded. Restarting services...');
              startServices(newConfig);
            } else {
              logger.error(`Configuration file is invalid or has been deleted. Services paused.`);
              if (clipboardWatcher) {
                clipboardWatcher.stop();
                clipboardWatcher = null;
              }
            }
          } catch (error) {
            logger.error(`Error reloading configuration: ${error instanceof Error ? error.message : String(error)}`);
          }
        }, 250);
      };

      // Initial startup
      const initialConfig = await loadConfigOrExit(cwd);
      const configPath = await findConfigPath(cwd);
      logger.success('Configuration loaded. Starting relaycode watch...');
      startServices(initialConfig);

      // Watch for changes after initial setup
      if (initialConfig.core.watchConfig && configPath) {
        logger.info(`Configuration file watching is enabled for ${path.basename(configPath)}.`);
        configWatcher = fs.watch(configPath, handleConfigChange);
      } else {
        logger.info('Configuration file watching is disabled. Changes to config will require a restart to take effect.');
      }

      const stopAll = () => {
        if (clipboardWatcher) {
          clipboardWatcher.stop();
        }
        if (configWatcher) {
          configWatcher.close();
          logger.info('Configuration file watcher stopped.');
        }
        if (debounceTimer) {
          clearTimeout(debounceTimer);
        }
      };
      return { stop: stopAll };
    };
  test/fixtures/e2e/complex-scenarios.yml: |-
    e2e_patch_tests:
      - name: multiple-operations
        description: Should handle multiple operations (edit, delete, new) in one transaction
        markdown_content: |
          I'm performing a few operations.

          First, editing `main.ts`.
          ```typescript // src/main.ts
          console.log("Updated main");
          ```

          Second, deleting `utils.ts`.
          ```typescript // src/utils.ts
          //TODO: delete this file
          ```

          Finally, adding a new component.
          ```typescript // "src/components/New Component.tsx"
          export const NewComponent = () => {
            return <div>New!</div>;
          };
          ```
        initial_state:
          - path: "src/main.ts"
            content: 'console.log("Original main");'
          - path: "src/utils.ts"
            content: 'export const util = {};'
        expected_state:
          - path: "src/main.ts"
            content: |
              console.log("Updated main");
          - path: "src/utils.ts"
            exists: false
          - path: "src/components/New Component.tsx"
            content: |
              export const NewComponent = () => {
                return <div>New!</div>;
              };

      - name: transaction-with-all-operation-types
        description: Should handle a single transaction with new, edit, rename, and delete operations
        markdown_content: |
          Here is a complex set of file modifications.

          First, I'll create a new config file.
          ```typescript // src/config.ts
          export const config = { timeout: 5000 };
          ```

          Next, I'll edit the main entrypoint to use this config.
          ```diff // src/main.ts new-unified
          --- src/main.ts
          +++ src/main.ts
          @@ ... @@
          -console.log("Starting...");
          +import { config } from './config';
          +console.log(`Starting with timeout ${config.timeout}...`);
          ```

          Then, I'll rename an old utility file.
          ```json // rename-file
          {
            "from": "src/utils.ts",
            "to": "src/lib/helpers.ts"
          }
          ```

          Finally, I'm removing a deprecated file.
          ```typescript // src/deprecated.ts
          //TODO: delete this file
          ```
        initial_state:
          - path: "src/main.ts"
            content: 'console.log("Starting...");'
          - path: "src/utils.ts"
            content: 'export function oldUtil() {}'
          - path: "src/deprecated.ts"
            content: '// This is old'
        expected_state:
          - path: "src/config.ts"
            content: |
              export const config = { timeout: 5000 };
          - path: "src/main.ts"
            content: |
              import { config } from './config';
              console.log(`Starting with timeout ${config.timeout}...`);
          - path: "src/utils.ts"
            exists: false
          - path: "src/lib/helpers.ts"
            content: "export function oldUtil() {}"
          - path: "src/deprecated.ts"
            exists: false
  test/fixtures/e2e/edge-cases.yml: |-
    e2e_patch_tests:
      - name: edit-file-with-spaces-in-path
        description: Should correctly edit a file that has spaces in its path
        markdown_content: |
          ```diff // "src/components/My Component.tsx" new-unified
          --- "src/components/My Component.tsx"
          +++ "src/components/My Component.tsx"
          @@ ... @@
           export const MyComponent = () => (
          -  <div>Hello</div>
          +  <div>Hello World</div>
           );
          ```
        initial_state:
          - path: "src/components/My Component.tsx"
            content: |
              export const MyComponent = () => (
                <div>Hello</div>
              );
        expected_state:
          - path: "src/components/My Component.tsx"
            content: |
              export const MyComponent = () => (
                <div>Hello World</div>
              );

      - name: edit-empty-file
        description: Should correctly add content to an empty file
        markdown_content: |
          ```typescript // src/empty.js
          // This file is no longer empty.
          export const ready = true;
          ```
        initial_state:
          - path: "src/empty.js"
            content: ""
        expected_state:
          - path: "src/empty.js"
            content: |
              // This file is no longer empty.
              export const ready = true;

      - name: create-and-then-edit-file
        description: Should handle creating a file and then editing it in the same transaction
        markdown_content: |
          First, create a new file.
          ```typescript // src/service.ts
          export class Service {
            run() { console.log('running'); }
          }
          ```

          Now, add a method to it.
          ```diff // src/service.ts new-unified
          --- src/service.ts
          +++ src/service.ts
          @@ ... @@
           export class Service {
          +  stop() { console.log('stopping'); }
             run() { console.log('running'); }
           }
          ```
        initial_state: []
        expected_state:
          - path: "src/service.ts"
            content: |
              export class Service {
                stop() { console.log('stopping'); }
                run() { console.log('running'); }
              }
  test/e2e/transaction.test.ts: >
    import { describe, it, expect, beforeEach, afterEach } from 'bun:test';

    import { promises as fs } from 'fs';

    import path from 'path';

    import { v4 as uuidv4 } from 'uuid';

    import { setupE2ETest, E2ETestContext, createTestFile, runProcessPatch }
    from '../test.util';

    import { STATE_DIRECTORY_NAME } from '../../src/utils/constants';

    import { readStateFile } from '../../src/core/state';

    import type { StateFile } from 'relaycode-core';


    describe('e2e/transaction', () => {
      let context: E2ETestContext;
      const testFile = 'src/index.ts';
      const originalContent = 'console.log("original");';

      beforeEach(async () => {
        context = await setupE2ETest({ withTsconfig: true });
        await createTestFile(context.testDir.path, testFile, originalContent);
      });

      afterEach(async () => {
        if (context) await context.cleanup();
      });

      it('should apply changes, commit, and store correct state in the database', async () => {
        const newContent = 'console.log("new content");';
        const { uuid } = await runProcessPatch(
          context,
          { linter: '', approvalMode: 'auto' },
          [{ type: 'edit', path: testFile, content: newContent }]
        );
        // Add a small delay to ensure file operations have completed
        await new Promise(resolve => setTimeout(resolve, 100));

        // Check file content
        const finalContent = await fs.readFile(path.join(context.testDir.path, testFile), 'utf-8');
        expect(finalContent).toBe(newContent);

        const stateData = await readStateFile(context.testDir.path, uuid);

        expect(stateData).not.toBeNull();
        if (!stateData) return; // type guard

        expect(stateData.uuid).toBe(uuid);
        expect(stateData.approved).toBe(true);
        expect(stateData.operations).toHaveLength(1);
        expect(stateData.operations[0].path).toBe(testFile);
        expect(stateData.snapshot[testFile]).toBe(originalContent);
        expect(stateData.reasoning).toBeDefined();
      });

      it('should rollback changes when manually disapproved', async () => {
        const { uuid } = await runProcessPatch(
          context,
          { approvalMode: 'manual' },
          [{ type: 'edit', path: testFile, content: 'console.log("I will be rolled back");' }],
          { prompter: async () => false }
        );

        const finalContent = await fs.readFile(path.join(context.testDir.path, testFile), 'utf-8');
        expect(finalContent).toBe(originalContent);

        const stateData = await readStateFile(context.testDir.path, uuid);
        expect(stateData).toBeNull();
      });

      it('should fallback to shell execution for non-tsc linters and require approval on failure', async () => {
        await runProcessPatch(
          context,
          // 'false' is a command that always exits with 1. This tests the shell fallback.
          { approvalMode: 'auto', approvalOnErrorCount: 0, linter: 'false' },
          [{ type: 'edit', path: testFile, content: 'any content' }],
          { prompter: async () => false } // Disapprove manually
        );

        const finalContent = await fs.readFile(path.join(context.testDir.path, testFile), 'utf-8');
        expect(finalContent).toBe(originalContent); // Should be rolled back
      });

      it('should require manual approval if linter errors exceed approvalOnErrorCount', async () => {
        await runProcessPatch(
          context,
          { approvalMode: 'auto', approvalOnErrorCount: 0, linter: 'bun tsc -b --noEmit' },
          [{ type: 'edit', path: testFile, content: 'const x: string = 123;' }],
          { prompter: async () => false }
        );

        const finalContent = await fs.readFile(path.join(context.testDir.path, testFile), 'utf-8');
        expect(finalContent).toBe(originalContent);
      });

      it('should skip linter if command is empty and auto-approve', async () => {
        const badContent = 'const x: string = 123;'; // Would fail linter, but it's skipped

        await runProcessPatch(
          context,
          { linter: '' },
          [{ type: 'edit', path: testFile, content: badContent }]
        );

        const finalContent = await fs.readFile(path.join(context.testDir.path, testFile), 'utf-8');
        expect(finalContent).toBe(badContent);
      });

      it('should ignore patch with already processed UUID', async () => {
        const uuid = uuidv4();

        // 1. Process and commit a patch
        await runProcessPatch(context, {}, [{ type: 'edit', path: testFile, content: "first change" }], { responseOverrides: { uuid } });

        // 2. Try to process another patch with the same UUID - this will create a new response with the same UUID.
        // The `processPatch` logic should see the existing state file and ignore it.
        await runProcessPatch(context, {}, [{ type: 'edit', path: testFile, content: "second change" }], { responseOverrides: { uuid } });

        // Content should be from the first change, not the second
        const finalContent = await fs.readFile(path.join(context.testDir.path, testFile), 'utf-8');
        expect(finalContent).toBe("first change");
      });

      it('should create nested directories for new files', async () => {
        const newFilePath = 'src/a/b/c/new-file.ts';
        const newFileContent = 'hello world';

        await runProcessPatch(
          context,
          {},
          [{ type: 'new', path: newFilePath, content: newFileContent }]
        );

        const finalContent = await fs.readFile(path.join(context.testDir.path, newFilePath), 'utf-8');
        expect(finalContent).toBe(newFileContent);
      });

      it('should rollback new file and its new empty parent directory on rejection', async () => {
        const newFilePath = 'src/new/dir/file.ts';

        await runProcessPatch(context, { approvalMode: 'manual' },
          [{ type: 'new', path: newFilePath, content: 'content' }], { prompter: async () => false });

        const fileExists = await fs.access(path.join(context.testDir.path, newFilePath)).then(() => true).catch(() => false);
        expect(fileExists).toBe(false);

        const dirExists = await fs.access(path.join(context.testDir.path, 'src/new/dir')).then(() => true).catch(() => false);
        expect(dirExists).toBe(false);

        const midDirExists = await fs.access(path.join(context.testDir.path, 'src/new')).then(() => true).catch(() => false);
        expect(midDirExists).toBe(false);

        // src directory should still exist as it contained a file before
        const srcDirExists = await fs.access(path.join(context.testDir.path, 'src')).then(() => true).catch(() => false);
        expect(srcDirExists).toBe(true);
      });

      it('should not delete parent directory on rollback if it was not empty beforehand', async () => {
        const existingFilePath = 'src/shared/existing.ts';
        const newFilePath = 'src/shared/new.ts';

        await createTestFile(context.testDir.path, existingFilePath, 'const existing = true;');

        await runProcessPatch(context, { approvalMode: 'manual' },
          [{ type: 'new', path: newFilePath, content: 'const brandNew = true;' }],
          { prompter: async () => false });

        // New file should be gone
        const newFileExists = await fs.access(path.join(context.testDir.path, newFilePath)).then(() => true).catch(() => false);
        expect(newFileExists).toBe(false);

        // Existing file and its directory should remain
        const existingFileExists = await fs.access(path.join(context.testDir.path, existingFilePath)).then(() => true).catch(() => false);
        expect(existingFileExists).toBe(true);

        const sharedDirExists = await fs.access(path.join(context.testDir.path, 'src/shared')).then(() => true).catch(() => false);
        expect(sharedDirExists).toBe(true);
      });

      it('should abort transaction if preCommand fails', async () => {
        const { uuid } = await runProcessPatch(
          context,
          { preCommand: 'false' },
          [{ type: 'edit', path: testFile, content: 'new content' }]
        );

        // File should not have been changed
        const finalContent = await fs.readFile(path.join(context.testDir.path, testFile), 'utf-8');
        expect(finalContent).toBe(originalContent);

        // No state file should have been created
        const stateData = await readStateFile(context.testDir.path, uuid);
        expect(stateData).toBeNull();
      });

      it('should automatically roll back if postCommand fails', async () => {
        const { uuid } = await runProcessPatch(
          context,
          { postCommand: 'false' },
          [{ type: 'edit', path: testFile, content: 'new content' }]
        );

        // File should have been rolled back
        const finalContent = await fs.readFile(path.join(context.testDir.path, testFile), 'utf-8');
        expect(finalContent).toBe(originalContent);

        // No state file should have been committed
        const stateData = await readStateFile(context.testDir.path, uuid);
        expect(stateData).toBeNull();
      });

      it('should ignore patch with non-matching projectId', async () => {
        const { uuid } = await runProcessPatch(
          context,
          { projectId: 'correct-project' },
          [{ type: 'edit', path: testFile, content: 'should not be applied' }],
          { responseOverrides: { projectId: 'wrong-project' } }
        );

        const finalContent = await fs.readFile(path.join(context.testDir.path, testFile), 'utf-8');
        expect(finalContent).toBe(originalContent);

        // No state file should have been committed
        const stateData = await readStateFile(context.testDir.path, uuid);
        expect(stateData).toBeNull();
      });

      it('should correctly apply a file deletion operation', async () => {
        const fileToDelete = 'src/delete-me.ts';
        const originalDeleteContent = 'delete this content';
        await createTestFile(context.testDir.path, fileToDelete, originalDeleteContent);

        const { uuid } = await runProcessPatch(
          context,
          {},
          [{ type: 'delete', path: fileToDelete }]
        );

        const deletedFileExists = await fs.access(path.join(context.testDir.path, fileToDelete)).then(() => true).catch(() => false);
        expect(deletedFileExists).toBe(false);

        const stateData = await readStateFile(context.testDir.path, uuid);
        expect(stateData).not.toBeNull();
      });

      it('should correctly roll back a file deletion operation', async () => {
        const fileToDelete = 'src/delete-me.ts';
        const originalDeleteContent = 'delete this content';
        await createTestFile(context.testDir.path, fileToDelete, originalDeleteContent);

        const { uuid } = await runProcessPatch(
          context, { approvalMode: 'manual' },
          [{ type: 'delete', path: fileToDelete }], { prompter: async () => false }
        );

        const restoredFileExists = await fs.access(path.join(context.testDir.path, fileToDelete)).then(() => true).catch(() => false);
        expect(restoredFileExists).toBe(true);

        // Content should be the same as the original
        const restoredContent = await fs.readFile(path.join(context.testDir.path, fileToDelete), 'utf-8');
        expect(restoredContent).toBe(originalDeleteContent);

        // No state file should have been committed
        const stateData = await readStateFile(context.testDir.path, uuid);
        expect(stateData).toBeNull();
      });

      it('should auto-approve if linter errors are within approvalOnErrorCount', async () => {
        const badContent = 'const x: string = 123;'; // 1 TS error

        const { uuid } = await runProcessPatch(
          context,
          { approvalMode: 'auto', approvalOnErrorCount: 1, linter: 'bun tsc -b --noEmit' },
          [{ type: 'edit', path: testFile, content: badContent }]
        );

        const finalContent = await fs.readFile(path.join(context.testDir.path, testFile), 'utf-8');
        expect(finalContent).toBe(badContent);

        // State file should have been committed
        const stateData = await readStateFile(context.testDir.path, uuid);
        expect(stateData).not.toBeNull();
      });

      it('should overwrite an orphaned pending transaction and allow reprocessing', async () => {
        const uuid = uuidv4();
        const newContent = 'console.log("final content");';

        // Create an orphaned pending transaction by running a patch and not approving it.
        // We'll use a trick: have the prompter throw an error to simulate a crash after the pending state is written.
        try {
          await runProcessPatch(
            context,
            { approvalMode: 'manual' },
            [{ type: 'edit', path: testFile, content: "this won't be applied" }],
            { responseOverrides: { uuid }, prompter: async () => { throw new Error('Simulated crash'); } }
          );
        } catch (e: any) {
          expect(e.message).toBe('Simulated crash');
        }

        await runProcessPatch(
          context,
          {},
          [{ type: 'edit', path: testFile, content: newContent }],
          { responseOverrides: { uuid } }
        );
        const finalContent = await fs.readFile(path.join(context.testDir.path, testFile), 'utf-8');
        expect(finalContent).toBe(newContent);

        // A committed state file should exist
        const stateData = await readStateFile(context.testDir.path, uuid);
        expect(stateData).not.toBeNull();
        if (!stateData) return;
        // The final committed reasoning should be from the second run.
        expect(stateData.operations[0].content).toContain('final content');
      });

      it('should run pre and post commands in the correct order', async () => {
        const preCommandFile = path.join(context.testDir.path, 'pre.txt');
        const postCommandFile = path.join(context.testDir.path, 'post.txt');

        // Use a synchronous file write to avoid potential race conditions or async flushing issues
        // with `node -e` in a shelled-out process.
        const preCommand = `node -e "require('fs').writeFileSync('${preCommandFile.replace(/\\/g, '/')}', '')"`;
        const postCommand = `node -e "require('fs').writeFileSync('${postCommandFile.replace(/\\/g, '/')}', '')"`;

        await runProcessPatch(
          context,
          {
            preCommand,
            postCommand,
          },
          [{ type: 'edit', path: testFile, content: 'new content' }]
        );

        const preExists = await fs.access(preCommandFile).then(() => true).catch(() => false);
        expect(preExists).toBe(true);

        const postExists = await fs.access(postCommandFile).then(() => true).catch(() => false);
        expect(postExists).toBe(true);

        const finalContent = await fs.readFile(path.join(context.testDir.path, testFile), 'utf-8');
        expect(finalContent).toBe('new content');
      });

      it('should create a pending record during transaction and mark as undone on rollback', async () => {
        const uuid = uuidv4();

        // We can't easily check the DB *during* the transaction.
        // Instead, we will check that no committed record exists after rollback.
        // The state transition is pending -> undone.
        // We don't have a way to check for 'undone' records with the current state API,
        // but we can check that it's not 'committed'.

        // Check if the pending file exists during the transaction
        // This part is no longer testable in the same way with an in-process DB.
        // let pendingFileExistedDuringRun = false;

        const prompter = async (): Promise<boolean> => {
          // pendingFileExistedDuringRun = (await getDb(context.testDir.path).query().from('transactions').where({ uuid, status: 'pending' }).first()) != null;
          return false; // Disapprove to trigger rollback
        };

        await runProcessPatch(
          context,
          { approvalMode: 'manual' },
          [{ type: 'edit', path: testFile, content: 'I will be rolled back' }],
          { prompter, responseOverrides: { uuid } }
        );

        // No committed file should exist
        const committedState = await readStateFile(context.testDir.path, uuid);
        expect(committedState).toBeNull();
      });

      it('should fail transaction gracefully if a file is not writable and rollback all changes', async () => {
        const unwritableFile = 'src/unwritable.ts';
        const writableFile = 'src/writable.ts';
        const originalUnwritableContent = 'original unwritable';
        const originalWritableContent = 'original writable';

        await createTestFile(context.testDir.path, unwritableFile, originalUnwritableContent);
        await createTestFile(context.testDir.path, writableFile, originalWritableContent);

        const unwritableFilePath = path.join(context.testDir.path, unwritableFile);

        try {
          await fs.chmod(unwritableFilePath, 0o444); // Make read-only

          const { uuid } = await runProcessPatch(
            context, {},
            [
              { type: 'edit', path: writableFile, content: 'new writable content' },
              { type: 'edit', path: unwritableFile, content: 'new unwritable content' }
            ]
          );

          // Check file states: both should be rolled back to original content.
          const finalWritable = await fs.readFile(path.join(context.testDir.path, writableFile), 'utf-8');
          expect(finalWritable).toBe(originalWritableContent);

          const finalUnwritable = await fs.readFile(path.join(context.testDir.path, unwritableFile), 'utf-8');
          expect(finalUnwritable).toBe(originalUnwritableContent);

          // No state file should have been committed
          const stateData = await readStateFile(context.testDir.path, uuid);
          expect(stateData).toBeNull();
        } finally {
          // Make the file writable again to allow cleanup
          try {
            await fs.chmod(unwritableFilePath, 0o644);
          } catch (err) {
            console.error('Failed to restore file permissions:', err);
          }
        }
      });

      it('should rollback gracefully if creating a file in a non-writable directory fails', async () => {
        const readonlyDir = 'src/readonly-dir';
        const newFilePath = path.join(readonlyDir, 'new-file.ts');
        const readonlyDirPath = path.join(context.testDir.path, readonlyDir);

        await fs.mkdir(readonlyDirPath, { recursive: true });
        await fs.chmod(readonlyDirPath, 0o555); // Read and execute only

        try {
          const { uuid } = await runProcessPatch(
            context,
            {},
            [{ type: 'new', path: newFilePath, content: 'this should not be written' }]
          );

          // Check that the new file was not created
          const newFileExists = await fs.access(path.join(context.testDir.path, newFilePath)).then(() => true).catch(() => false);
          expect(newFileExists).toBe(false);

          // No state file should have been committed
          const stateData = await readStateFile(context.testDir.path, uuid);
          expect(stateData).toBeNull();
        } finally {
          // Restore permissions for cleanup
          try {
            // The directory might have been removed on rollback, so check if it exists first.
            if (await fs.access(readonlyDirPath).then(() => true).catch(() => false)) {
              await fs.chmod(readonlyDirPath, 0o755);
            }
          } catch (err) {
            console.error('Failed to restore directory permissions:', err);
          }
        }
      });

      it('should correctly rollback a complex transaction (modify, delete, create)', async () => {
        // Setup initial files
        const fileToModify = 'src/modify.ts';
        const originalModifyContent = 'export const a = 1;';
        await createTestFile(context.testDir.path, fileToModify, originalModifyContent);

        const fileToDelete = 'src/delete.ts';
        const originalDeleteContent = 'export const b = 2;';
        await createTestFile(context.testDir.path, fileToDelete, originalDeleteContent);

        const newFilePath = 'src/new/component.ts';
        const newFileContent = 'export const c = 3;';

        // Disapprove the transaction
        await runProcessPatch(
          context,
          { approvalMode: 'manual' },
          [
            { type: 'edit', path: fileToModify, content: 'export const a = 100;' },
            { type: 'delete', path: fileToDelete },
            { type: 'new', path: newFilePath, content: newFileContent }
          ], { prompter: async () => false }
        );

        // Verify rollback
        const modifiedFileContent = await fs.readFile(path.join(context.testDir.path, fileToModify), 'utf-8');
        expect(modifiedFileContent).toBe(originalModifyContent);

        const deletedFileExists = await fs.access(path.join(context.testDir.path, fileToDelete)).then(() => true).catch(() => false);
        expect(deletedFileExists).toBe(true);

        const deletedFileContent = await fs.readFile(path.join(context.testDir.path, fileToDelete), 'utf-8');
        expect(deletedFileContent).toBe(originalDeleteContent);

        const newFileExists = await fs.access(path.join(context.testDir.path, newFilePath)).then(() => true).catch(() => false);
        expect(newFileExists).toBe(false);
      });

      it('should correctly apply multiple sequential operations on the same file, including a rename', async () => {
        const originalFilePath = 'src/service.ts';
        const renamedFilePath = 'src/services/main-service.ts';
        const originalServiceContent = `class Service {
        name = "MyService";

        execute() {
            console.log("Executing service");
        }
    }`;
        await createTestFile(context.testDir.path, originalFilePath, originalServiceContent);

        // First, a standard diff to rename a property and add a new one.
        const unifiedDiff = `--- a/${originalFilePath}
    +++ b/${originalFilePath}

    @@ -1,5 +1,6 @@
     class Service {
    -     name = "MyService";

    +    name = "MyAwesomeService";

    +    version = "1.0";

         execute() {
             console.log("Executing service");
        }
    }`;

        // Then, a search-replace to update a method on the *result* of the first patch.
        const searchReplaceDiff = `
    <<<<<<< SEARCH
            console.log("Executing service");
    =======
            console.log(\`Executing service \${this.name} v\${this.version}\`);
    >>>>>>> REPLACE

    `;

        // And finally, rename the file.
        const { uuid } = await runProcessPatch(
          context,
          {},
          [
            { type: 'edit', path: originalFilePath, content: unifiedDiff, strategy: 'new-unified' },
            { type: 'edit', path: originalFilePath, content: searchReplaceDiff, strategy: 'multi-search-replace' },
            { type: 'rename', from: originalFilePath, to: renamedFilePath },
          ]
        );

        // 1. Verify file system state
        const originalFileExists = await fs.access(path.join(context.testDir.path, originalFilePath)).then(() => true).catch(() => false);
        expect(originalFileExists).toBe(false);

        const renamedFileExists = await fs.access(path.join(context.testDir.path, renamedFilePath)).then(() => true).catch(() => false);
        expect(renamedFileExists).toBe(true);

        // 2. Verify final content
        const finalContent = await fs.readFile(path.join(context.testDir.path, renamedFilePath), 'utf-8');
        const expectedContent = `class Service {
        name = "MyAwesomeService";
        version = "1.0";

        execute() {
            console.log(\`Executing service \${this.name} v\${this.version}\`);
        }
    }`;
        expect(finalContent.replace(/\s/g, '')).toBe(expectedContent.replace(/\s/g, ''));

        // 3. Verify snapshot in state file for rollback purposes
        const stateData = await readStateFile(context.testDir.path, uuid);
        expect(stateData).not.toBeNull();
        expect(stateData?.snapshot[originalFilePath]).toBe(originalServiceContent);
        expect(stateData?.snapshot[renamedFilePath]).toBe(null); // It didn't exist at snapshot time
      });
    });
  test/fixtures/e2e/success.yml: |-
    e2e_patch_tests:
      - name: apply-search-replace
        description: Should correctly apply a patch using the search-replace strategy
        markdown_content: |
          ```json // src/config.js search-replace
          <<<<<<< SEARCH
              port: 3000,
          =======
              port: 8080,
          >>>>>>> REPLACE
          <<<<<<< SEARCH
              enableLogging: true,
          =======
              enableLogging: false,
          >>>>>>> REPLACE
          ```
        initial_state:
          - path: "src/config.js"
            content: |
              const config = {
                  port: 3000,
                  host: 'localhost',
                  enableLogging: true,
              };
        expected_state:
          - path: "src/config.js"
            content: |
              const config = {
                  port: 8080,
                  host: 'localhost',
                  enableLogging: false,
              };

      - name: apply-standard-diff
        description: Should correctly apply a patch using the standard-diff strategy
        markdown_content: |
          ```diff // src/utils.js standard-diff
          --- a/src/utils.js
          +++ b/src/utils.js
          @@ -2,4 +2,5 @@
               const a = 1;
               const b = 2;
          -    return a + b;
          +    // A more complex calculation
          +    return (a + b) * 2;
           }
          ```
        initial_state:
          - path: "src/utils.js"
            content: |
              function calculate() {
                  const a = 1;
                  const b = 2;
                  return a + b;
              }
        expected_state:
          - path: "src/utils.js"
            content: |
              function calculate() {
                  const a = 1;
                  const b = 2;
                  // A more complex calculation
                  return (a + b) * 2;
              }

      - name: apply-new-unified-diff
        description: Should correctly apply a patch using the new-unified strategy
        markdown_content: |
          ```diff // src/app.js new-unified
          --- src/app.js
          +++ src/app.js
          @@ ... @@
           function main() {
          -  console.log("Hello World");
          +  console.log("Hello, Universe!");
           }
          ```
        initial_state:
          - path: "src/app.js"
            content: |
              function main() {
                console.log("Hello World");
              }
        expected_state:
          - path: "src/app.js"
            content: |
              function main() {
                console.log("Hello, Universe!");
              }
approved: true
