uuid: d892d77d-784f-4d2c-800d-525996f8c7e0
projectId: relaycode
createdAt: '2025-09-12T02:03:04.041Z'
gitCommitMsg: >-
  feat(workflow): Overhaul transaction approval to be interactive

  This commit revamps the transaction approval process to be more interactive
  and user-friendly, and reduces terminal noise.

  - All new transactions from the watcher now prompt for immediate yes/no
  approval, rather than being queued as pending. - The `approve-all` command is
  now interactive by default, allowing users to review and approve/reject each
  pending transaction individually. The `--yes` flag can be used to approve all
  without prompting. - Terminal output from the clipboard watcher is now less
  verbose by default. - Upon approving a transaction, the path to its state file
  is now logged to the console.
promptSummary: >-
  The user wants to change the transaction approval flow to be interactive for
  every transaction, make the terminal output less noisy, and see the path to
  the transaction file upon approval. They also want the 'approve-all' command
  to allow for approving specific pending transactions.
reasoning:
  - >-
    As an expert AI programmer, I've analyzed your request to improve the
    transaction approval workflow and reduce terminal noise. I'll implement a
    more interactive and user-friendly process. Here's my plan:
  - >-
    1.  **Interactive Approvals**: I will modify the `watch` command's behavior.
    Instead of placing new patches into a pending queue, it will now prompt you
    for immediate approval (`yes`/`no`) for each transaction. This applies even
    when using bulk clipboard mode, where the "bulk" aspect will now refer to
    gathering patches, not deferring their approval.
  - >-
    2.  **Enhanced `approve-all` Command**: I will overhaul the `approve-all`
    command to be interactive. It will now present each pending transaction one
    by one, showing its details and asking for your approval. This allows you to
    approve or reject specific transactions. A `--yes` flag will be available to
    preserve the old behavior of approving all transactions at once.
  - >-
    3.  **Quieter Operation**: I'll reduce the noise in the terminal during
    watch mode by changing the frequent "New clipboard content detected" and
    "Ignoring" messages from informational logs to debug logs, so they won't
    appear by default.
  - >-
    4.  **Clearer Feedback**: Upon successful approval of a transaction, I will
    now display the file path to the newly created transaction record, giving
    you better visibility into where the state is stored.
  - 'Here are the code modifications to achieve this:'
  - '### 1. Make `approve-all` Interactive'
  - >-
    I'll start by updating the `approve-all` command to accept a `--yes` flag
    and pass it to the core transaction logic.
  - '### 2. Reduce Terminal Noise in Watch Mode'
  - >-
    Next, I'll adjust the log levels for the clipboard watcher to make it less
    verbose during normal operation.
  - '### 3. Display Transaction File Path on Approval'
  - >-
    I will modify the database logic to retrieve and return the path of the
    transaction file when it's committed.
  - '### 4. Implement Core Logic for New Approval Flow'
  - >-
    Finally, I'll update the main transaction processing file. This change
    removes the automatic "pending" status for watched patches, makes
    `approveAllPendingTransactions` interactive, and refactors bulk processing
    to use the new interactive approval for each patch.
  - >-
    These changes will provide a much more interactive and streamlined workflow,
    directly addressing your feedback.
operations:
  - type: write
    path: src/commands/approve-all.ts
    content: >+
      --- src/commands/approve-all.ts

      +++ src/commands/approve-all.ts

      @@ -2,8 +2,8 @@
       import { approveAllPendingTransactions } from '../core/transaction';
       import { logger } from '../utils/logger';
       
      -export const approveAllCommand = async (_options: {}) => {

      +export const approveAllCommand = async (options: { yes?: boolean }) => {
         const config = await loadConfigOrExit();
      -  logger.info('Checking for pending transactions...');

      -  await approveAllPendingTransactions(config, process.cwd());

      +  logger.info('Reviewing pending transactions...');

      +  await approveAllPendingTransactions(config, process.cwd(),
      options.yes);
       };

    patchStrategy: standard-diff
  - type: write
    path: src/commands/watch.ts
    content: >
      --- src/commands/watch.ts

      +++ src/commands/watch.ts

      @@ -29,12 +29,12 @@
           };
       
           const watcherCallback = (content: string) => {
      -      logger.info('New clipboard content detected. Attempting to
      parse...');

      +      logger.debug('New clipboard content detected. Attempting to
      parse...');
             const parsedResponse = parseLLMResponse(content);
       
             if (!parsedResponse) {
      -        logger.info('Clipboard content is not a valid relaycode patch.
      Ignoring.');

      +        logger.debug('Clipboard content is not a valid relaycode patch.
      Ignoring.');
               return;
             }
       
    patchStrategy: standard-diff
  - type: write
    path: src/core/state.ts
    content: >+
      --- src/core/state.ts

      +++ src/core/state.ts

      @@ -2,6 +2,7 @@
       import { logger } from '../utils/logger';
       import { getDb, toStateFile, fromStateFile } from './db';
       import { promises as fs } from 'fs';
      +import path from 'path';
       import { getStateDirectory } from './config';
       
       export const isRevertTransaction = (state: StateFile): boolean => {
      @@ -28,15 +29,23 @@
         // ...
       };
       
      -export const commitState = async (cwd: string, uuid: string):
      Promise<void> => {

      +export const commitState = async (cwd: string, uuid: string):
      Promise<string | null> => {
         const db = getDb(cwd);
         // Also update status from 'pending' to 'committed'
      -  await db.update('transactions').set({ status: 'committed' }).where({
      uuid });

      +  const updated = await db.update('transactions').set({ status:
      'committed' }).where({ uuid });

      +

      +  if (updated.length > 0) {

      +    const record = updated[0] as { id: number };

      +    const stateDir = getStateDirectory(cwd);

      +    // Path construction based on konro's per-record strategy. The double
      'transactions' is intentional.

      +    // <stateDir>/<dbName>/<tableName>/<recordId>.json

      +    const filePath = path.join(stateDir, 'transactions', 'transactions',
      `${record.id}.json`);

      +    return filePath;

      +  }

      +  return null;
       };
       
       export const markTransactionsAsGitCommitted = async (cwd: string, uuids: string[]): Promise<void> => {

    patchStrategy: standard-diff
  - type: write
    path: src/core/transaction.ts
    content: >+
      --- src/core/transaction.ts

      +++ src/core/transaction.ts

      @@ -148,9 +148,13 @@
         }
       
         if (approved) {
      -    await commitState(cwd, stateFile.uuid);

      -    logger.info(`‚úÖ Transaction approved and committed.`);

      +    const stateFilePath = await commitState(cwd, stateFile.uuid);

      +    logger.info(chalk.green(`‚úÖ Transaction approved and committed.`));

      +    if (stateFilePath) {

      +      logger.info(`   State file: ${chalk.gray(path.relative(cwd,
      stateFilePath))}`);

      +    }
       
           if (config.approve.autoGitAdd) {
             await handleAutoGitAdd(config, stateFile, cwd);
      @@ -194,22 +198,7 @@
           // Log summary before asking for approval
           logCompletionSummary(parsedResponse.uuid, startTime, operations);
       
      -    // Store transaction as pending for bulk approval

      -    if (config.watcher.bulk.enabled) {

      -      logger.info(`Transaction ${parsedResponse.uuid} is pending
      approval.`);

      -      await writePendingState(cwd, stateFile);

      -      logPendingApprovalMessage();

      -      return;

      -    }

      -

      -    // Only ask for individual approval if not in bulk mode
           const { approved } = await handleApproval({
             reason: 'Do you want to apply this patch?',
             stateFile,
      @@ -244,55 +233,47 @@
         return pendingTransactionCount;
       };
       
      -export const approveAllPendingTransactions = async (config: Config, cwd:
      string = process.cwd()): Promise<void> => {

      +export const approveAllPendingTransactions = async (config: Config, cwd:
      string = process.cwd(), yes: boolean = false): Promise<void> => {
         const db = getDb(cwd);
         const pendingStates = (await db.query().from('transactions').where({ status: 'pending' }).all()).map(toStateFile);
       
         if (pendingStates.length === 0) {
           logger.info('No pending transactions to approve.');
           return;
         }
       
      -  logger.info(`Found ${pendingStates.length} pending transaction(s).
      Approving all...`);

      -

      -  for (const tx of pendingStates) {

      -    logger.info(`Approving transaction ${tx.uuid}...`);

      -    // Re-process the patch, but with `yes: true` to auto-approve
      everything.

      -    await processPatch(config, tx, { cwd, yes: true });

      -    // This will re-apply, re-check, and then commit.

      +  if (yes) {

      +    logger.info(`Found ${pendingStates.length} pending transaction(s).
      Approving all...`);

      +    for (const tx of pendingStates) {

      +      await processPatch(config, tx, { cwd, yes: true });

      +    }

      +    return;

      +  }

      +

      +  logger.info(`Found ${pendingStates.length} pending transaction(s) for
      review.`);

      +  const prompter = createConfirmationHandler({});

      +  for (const tx of pendingStates) {

      +    logger.info(chalk.cyan(`\n${'-'.repeat(50)}`));

      +    const details = formatTransactionDetails(tx, { showOperations: true,
      showReasoning: true, showSpacing: true });

      +    details.forEach(line => logger.info(line));

      +

      +    const approve = await prompter('Do you want to approve this
      transaction?');

      +    if (approve) {

      +      logger.info(`Approving transaction ${tx.uuid}...`);

      +      await processPatch(config, tx, { cwd, yes: true });

      +    } else {

      +      await deletePendingState(cwd, tx.uuid);

      +      logger.info(`Transaction ${tx.uuid} was rejected and removed.`);

      +    }
         }
       };
       
       export const processPatchesBulk = async (config: Config, parsedResponses: ParsedLLMResponse[], options?: ProcessPatchOptions): Promise<void> => {
      -  const cwd = options?.cwd ?? process.cwd();

      -

      -  // Filter out invalid patches

      -  const validResponses = parsedResponses.filter(r => {

      -    if (r.projectId !== config.projectId) {

      -      logger.debug(`Ignoring patch for project '${r.projectId}' because
      it doesn't match current project '${config.projectId}'.`);

      -      return false;

      -    }

      -    return true;

      -  });

      -

      -  if (validResponses.length === 0) {

      -    return;

      -  }

      -

      -  logger.info(`Processing ${validResponses.length} patch(es) in
      bulk...`);

      -

      -  // Process all patches sequentially but with bulk approval

      -  for (const parsedResponse of validResponses) {

      -    // For bulk processing, we want to skip individual approvals

      -    // and handle approval at the end

      -    await _processPatch(config, parsedResponse, { ...options, cwd,
      skipIndividualApproval: true });

      -  }

      -

      -  // Ask for bulk approval at the end

      -  const pendingCount = getPendingTransactionCount(cwd);

      -  if (pendingCount > 0) {

      -   
      logger.info(chalk.cyan('--------------------------------------------------'));

      -    logPendingApprovalMessage();

      +  // In bulk mode, process each patch individually, which will trigger
      individual approvals.

      +  // The "bulk" aspect is about clipboard gathering, not approval.

      +  for (const parsedResponse of parsedResponses) {

      +    await processPatch(config, parsedResponse, options);
         }
       };
       
       const handleAutoGitBranch = async (config: Config, stateFile: StateFile, cwd: string): Promise<void> => {

    patchStrategy: standard-diff
snapshot:
  src/commands/approve-all.ts: >-
    import { loadConfigOrExit } from '../core/config';

    import { approveAllPendingTransactions } from '../core/transaction';

    import { logger } from '../utils/logger';


    export const approveAllCommand = async (_options: { yes?: boolean } = {},
    cwd: string = process.cwd()): Promise<void> => {
      const config = await loadConfigOrExit(cwd);
      logger.setLevel(config.core.logLevel);
      
      await approveAllPendingTransactions(config, cwd);
    };
  src/commands/watch.ts: >
    import { findConfig, loadConfigOrExit, findConfigPath } from
    '../core/config';

    import { createClipboardWatcher, createBulkClipboardWatcher } from
    '../core/clipboard';

    import { parseLLMResponse, type ParsedLLMResponse } from 'relaycode-core';

    import { processPatch, processPatchesBulk, getPendingTransactionCount } from
    '../core/transaction';

    import { logger } from '../utils/logger';

    import { type Config } from 'relaycode-core';

    import fs from 'fs';

    import path from 'path';


    const getSystemPrompt = (
      projectId: string,
      preferredStrategy: Config['watcher']['preferredStrategy'],
      patchConfig: Config['patch'],
    ): string => {
        const header = `
    ‚úÖ relaycode is watching for changes.


    IMPORTANT: For relaycode to work, you must configure your AI assistant.

    Copy the entire text below and paste it into your LLM's "System Prompt"

    or "Custom Instructions" section.

    ---------------------------------------------------------------------------`;

      const intro = `You are an expert AI programmer. To modify a file, you MUST use a code block with a specified patch strategy.`;

      const syntaxAuto = `
    **Syntax:**

    \`\`\`typescript // filePath {patchStrategy}

    ... content ...

    \`\`\`

    - \`filePath\`: The path to the file. **If the path contains spaces, it MUST
    be enclosed in double quotes.**

    - \`patchStrategy\`: (Optional) One of \`standard-diff\`,
    \`search-replace\`. If omitted, the entire file is replaced (this is the
    \`replace\` strategy).


    **Examples:**

    \`\`\`typescript // src/components/Button.tsx

    ...

    \`\`\`

    \`\`\`typescript // "src/components/My Component.tsx" standard-diff

    ...

    \`\`\``;

      const syntaxReplace = `
    **Syntax:**

    \`\`\`typescript // filePath

    ... content ...

    \`\`\`

    - \`filePath\`: The path to the file. **If the path contains spaces, it MUST
    be enclosed in double quotes.**

    - Only the \`replace\` strategy is enabled. This means you must provide the
    ENTIRE file content for any change. This is suitable for creating new files
    or making changes to small files.`;

      const syntaxStandardDiff = `
    **Syntax:**

    \`\`\`typescript // filePath standard-diff

    ... diff content ...

    \`\`\`

    - \`filePath\`: The path to the file. **If the path contains spaces, it MUST
    be enclosed in double quotes.**

    - You must use the \`standard-diff\` patch strategy for all modifications.`;

      const syntaxSearchReplace = `
    **Syntax:**

    \`\`\`typescript // filePath search-replace

    ... diff content ...

    \`\`\`

    - \`filePath\`: The path to the file. **If the path contains spaces, it MUST
    be enclosed in double quotes.**

    - You must use the \`search-replace\` patch strategy for all
    modifications.`;

      const sectionStandardDiff = `---

    ### Strategy 1: Advanced Unified Diff (\`standard-diff\`) - RECOMMENDED


    Use for most changes, like refactoring, adding features, and fixing bugs.
    It's resilient to minor changes in the source file.


    **Diff Format:**

    1.  **File Headers**: Start with \`--- {filePath}\` and \`+++ {filePath}\`.

    2.  **Hunk Header**: Use \`@@ ... @@\`. Exact line numbers are not needed.

    3.  **Context Lines**: Include 2-3 unchanged lines before and after your
    change for context.

    4.  **Changes**: Mark additions with \`+\` and removals with \`-\`. Maintain
    indentation.


    **Example:**

    \`\`\`diff

    --- src/utils.ts

    +++ src/utils.ts

    @@ ... @@
        function calculateTotal(items: number[]): number {
    -      return items.reduce((sum, item) => {

    -        return sum + item;

    -      }, 0);

    +      const total = items.reduce((sum, item) => {

    +        return sum + item * 1.1;  // Add 10% markup

    +      }, 0);

    +      return Math.round(total * 100) / 100;  // Round to 2 decimal places

    +    }

    \`\`\`

    `;

      const sectionSearchReplace = `---

    ### Strategy 2: Search-Replace (\`search-replace\`)


    Use for precise, surgical replacements. The \`SEARCH\` block must be an
    exact match of the content in the file.


    **Diff Format:**

    Repeat this block for each replacement.

    \`\`\`diff

    <<<<<<< SEARCH

    [exact content to find including whitespace]

    =======

    [new content to replace with]

    >>>>>>> REPLACE

    \`\`\`

    `;

      const otherOps = `---

    ### Other Operations


    -   **Creating a file**: Use the default \`replace\` strategy (omit the
    strategy name) and provide the full file content.

    -   **Deleting a file**:
        \`\`\`typescript // path/to/file.ts
        //TODO: delete this file
        \`\`\`
        \`\`\`typescript // "path/to/My Old Component.ts"
        //TODO: delete this file
        \`\`\`
    -   **Renaming/Moving a file**:
        \`\`\`json // rename-file
        {
          "from": "src/old/path/to/file.ts",
          "to": "src/new/path/to/file.ts"
        }
        \`\`\`
    `;

      const finalSteps_rules = [];
      if (patchConfig.minFileChanges > 0) {
        finalSteps_rules.push(`You must modify at least ${patchConfig.minFileChanges} file(s) in this transaction.`);
      }
      if (patchConfig.maxFileChanges) {
        finalSteps_rules.push(`You must not modify more than ${patchConfig.maxFileChanges} file(s) in this transaction.`);
      }

      const finalSteps_list = [
        'Add your step-by-step reasoning in plain text before each code block.',
      ];
      if (finalSteps_rules.length > 0) {
        finalSteps_list.push(`Adhere to file limits: ${finalSteps_rules.join(' ')}`);
      }
      finalSteps_list.push('ALWAYS add the following YAML block at the very end of your response. Use the exact projectId shown here. Generate a new random uuid for each response.');

      const finalSteps_list_string = finalSteps_list.map((item, index) => `${index + 1}.  ${item}`).join('\n');

      const finalSteps = `---

    ### Final Steps


    ${finalSteps_list_string}

        \`\`\`yaml
        projectId: ${projectId}
        uuid: (generate a random uuid)
        changeSummary: # A list of key-value pairs for changes
          - edit: src/main.ts
          - new: src/components/Button.tsx
          - delete: src/utils/old-helper.ts
        promptSummary: A brief summary of my request.
        gitCommitMsg: >-
          feat: A concise, imperative git commit message.

          Optionally, provide a longer description here.
        \`\`\`
    `;

      const footer = `---------------------------------------------------------------------------`;

      const strategyInfo = {
        auto: { syntax: syntaxAuto, details: `${sectionStandardDiff}\n${sectionSearchReplace}` },
        replace: { syntax: syntaxReplace, details: '' },
        'standard-diff': { syntax: syntaxStandardDiff, details: sectionStandardDiff },
        'search-replace': { syntax: syntaxSearchReplace, details: sectionSearchReplace },
      };

      const preferred = strategyInfo[preferredStrategy] ?? strategyInfo.auto;
      const syntax = preferred.syntax;
      const strategyDetails = preferred.details;

      return [header, intro, syntax, strategyDetails, otherOps, finalSteps, footer].filter(Boolean).join('\n');
    };


    export const watchCommand = async (options: { yes?: boolean } = {}, cwd:
    string = process.cwd()): Promise<{ stop: () => void }> => {
      let clipboardWatcher: { stop: () => void } | null = null;
      let configWatcher: fs.FSWatcher | null = null;
      let debounceTimer: NodeJS.Timeout | null = null;

      const startServices = (config: Config) => {
        // Stop existing watcher if it's running
        if (clipboardWatcher) {
          clipboardWatcher.stop();
        }

        logger.setLevel(config.core.logLevel);
        logger.debug(`Log level set to: ${config.core.logLevel}`);
        logger.debug(`Preferred strategy set to: ${config.watcher.preferredStrategy}`);

        logger.log(getSystemPrompt(config.projectId, config.watcher.preferredStrategy, config.patch));

        // Use bulk clipboard watcher if bulk mode is enabled
        if (config.watcher.enableBulkProcessing) {
          clipboardWatcher = createBulkClipboardWatcher(
            config.watcher.clipboardPollInterval,
            async (contents) => {
              logger.info(`Processing ${contents.length} clipboard items in bulk mode...`);
              
              const parsedResponses: ParsedLLMResponse[] = [];
              for (const content of contents) {
                const parsedResponse = parseLLMResponse(content);
                if (parsedResponse) {
                  parsedResponses.push(parsedResponse);
                }
              }

              if (parsedResponses.length === 0) {
                logger.warn('No valid relaycode patches found in clipboard content.');
                return;
              }

              await processPatchesBulk(config, parsedResponses, { cwd, notifyOnStart: true, yes: options.yes });
              const pendingCount = getPendingTransactionCount(cwd);
              logger.info('--------------------------------------------------');
              if (pendingCount > 0) {
                  logger.info(`üìã Watching for next patch... (${pendingCount} pending transaction(s) waiting for approval)`);
              } else {
                  logger.info('Watching for next patch...');
              }
            },
            config.watcher.bulkSize || 5,
            config.watcher.bulkTimeout || 30000
          );
        } else {
          clipboardWatcher = createClipboardWatcher(config.watcher.clipboardPollInterval, async (content) => {
            logger.info('New clipboard content detected. Attempting to parse...');
            const parsedResponse = parseLLMResponse(content);

            if (!parsedResponse) {
              logger.warn('Clipboard content is not a valid relaycode patch. Ignoring.');
              return;
            }

            // Check project ID before notifying and processing.
            if (parsedResponse.control.projectId !== config.projectId) {
              logger.debug(`Ignoring patch for different project (expected '${config.projectId}', got '${parsedResponse.control.projectId}').`);
              return;
            }

            await processPatch(config, parsedResponse, { cwd, notifyOnStart: true, yes: options.yes, skipIndividualApproval: true });
            const pendingCount = getPendingTransactionCount(cwd);
            logger.info('--------------------------------------------------');
            if (pendingCount > 0) {
                logger.info(`üìã Watching for next patch... (${pendingCount} pending transaction(s) waiting for approval)`);
            } else {
                logger.info('Watching for next patch...');
            }
          });
        }
      };

      const handleConfigChange = () => {
        if (debounceTimer) clearTimeout(debounceTimer);
        debounceTimer = setTimeout(async () => {
          logger.info(`Configuration file change detected. Reloading...`);
          try {
            const newConfig = await findConfig(cwd);
            if (newConfig) {
              logger.success('Configuration reloaded. Restarting services...');
              startServices(newConfig);
            } else {
              logger.error(`Configuration file is invalid or has been deleted. Services paused.`);
              if (clipboardWatcher) {
                clipboardWatcher.stop();
                clipboardWatcher = null;
              }
            }
          } catch (error) {
            logger.error(`Error reloading configuration: ${error instanceof Error ? error.message : String(error)}`);
          }
        }, 250);
      };

      // Initial startup
      const initialConfig = await loadConfigOrExit(cwd);
      const configPath = await findConfigPath(cwd);
      logger.success('Configuration loaded. Starting relaycode watch...');
      startServices(initialConfig);

      // Watch for changes after initial setup
      if (initialConfig.core.watchConfig && configPath) {
        logger.info(`Configuration file watching is enabled for ${path.basename(configPath)}.`);
        configWatcher = fs.watch(configPath, handleConfigChange);
      } else {
        logger.info('Configuration file watching is disabled. Changes to config will require a restart to take effect.');
      }

      const stopAll = () => {
        if (clipboardWatcher) {
          clipboardWatcher.stop();
        }
        if (configWatcher) {
          configWatcher.close();
          logger.info('Configuration file watcher stopped.');
        }
        if (debounceTimer) {
          clearTimeout(debounceTimer);
        }
      };
      return { stop: stopAll };
    };
  src/core/state.ts: >-
    import { type StateFile } from 'relaycode-core';

    import { logger } from '../utils/logger';

    import { getDb, toStateFile, fromStateFile } from './db';

    import { promises as fs } from 'fs';

    import { getStateDirectory } from './config';


    export const isRevertTransaction = (state: StateFile): boolean => {
        return state.reasoning.some(r => r.startsWith('Reverting transaction'));
    }


    export const getRevertedTransactionUuid = (state: StateFile): string | null
    => {
        for (const r of state.reasoning) {
            const match = r.match(/^Reverting transaction ([\w-]+)\./);
            if (match && match[1]) {
                return match[1];
            }
        }
        return null;
    }


    const isUUID = (str: string): boolean => {
      return /^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$/.test(str);
    };


    const sortByDateDesc = (a: { createdAt: string | Date }, b: { createdAt:
    string | Date }) => {
        return new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime();
    };


    export const hasBeenProcessed = async (cwd: string, uuid: string):
    Promise<boolean> => {
      const db = getDb(cwd);
      const record = await db.query().from('transactions').where({ uuid }).first();
      // 'committed' and 'undone' transactions are considered final.
      // 'pending' can be re-processed to handle orphaned transactions from crashes.
      return !!record && (record.status === 'committed' || record.status === 'undone');
    };


    export const writePendingState = async (cwd: string, state: StateFile):
    Promise<void> => {
      // Validate UUID to prevent undefined.yaml errors
      if (!state.uuid || typeof state.uuid !== 'string' || !state.uuid.match(/^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$/)) {
        logger.error(`Fatal: Invalid UUID provided for writePendingState: ${state.uuid}`);
        throw new Error(`Invalid UUID: ${state.uuid}`);
      }
      
      const db = getDb(cwd);
      // First, remove any orphaned pending transaction with the same UUID to prevent unique constraint errors.
      // This allows reprocessing of transactions that were interrupted or crashed.
      await db.delete('transactions').where((r) => r.uuid === state.uuid && r.status === 'pending');

      // Now, insert the new pending transaction.
      const data = { ...fromStateFile(state), status: 'pending' };
      await db.insert('transactions', data as any);
    };


    export const updatePendingState = async (cwd:string, state: StateFile):
    Promise<void> => {
        const db = getDb(cwd);
        const data = fromStateFile(state);
        const updated = await db.update('transactions').set(data as any).where({ uuid: state.uuid, status: 'pending' });
        if (updated.length === 0) {
            logger.warn(`Could not find pending transaction with uuid ${state.uuid} to update.`);
        }
    }


    export const commitState = async (cwd: string, uuid: string): Promise<void>
    => {
      const db = getDb(cwd);
      // Also update status from 'pending' to 'committed'
      const updated = await db.update('transactions').set({ status: 'committed' }).where({ uuid, status: 'pending' });
      if (updated.length === 0) {
          logger.warn(`Could not find pending transaction with uuid ${uuid} to commit.`);
      }
    };


    export const markTransactionsAsGitCommitted = async (cwd: string, uuids:
    string[]): Promise<void> => {
      const db = getDb(cwd);
      const gitCommittedAt = new Date().toISOString();
      
      for (const uuid of uuids) {
        const updated = await db.update('transactions').set({ gitCommittedAt }).where({ uuid, status: 'committed' });
        if (updated.length === 0) {
          logger.warn(`Could not find committed transaction with uuid ${uuid} to mark as git-committed.`);
        }
      }
    };


    export const deletePendingState = async (cwd: string, uuid: string):
    Promise<void> => {
      // Validate UUID to prevent undefined.yaml errors
      if (!uuid || typeof uuid !== 'string' || !uuid.match(/^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$/)) {
        logger.error(`Fatal: Invalid UUID provided for deletePendingState: ${uuid}`);
        return;
      }
      
      const db = getDb(cwd);
      // In case of rollback, we mark it as 'undone' instead of deleting.
      const updated = await db.update('transactions').set({ status: 'undone' }).where({ uuid, status: 'pending' });
      if (updated.length === 0) {
        logger.debug(`Could not find pending transaction with uuid ${uuid} to mark as undone. It might have been committed or already undone.`);
      }
    };


    export const readStateFile = async (cwd: string, uuid: string):
    Promise<StateFile | null> => {
      const db = getDb(cwd);
      const record = await db.query().from('transactions').where({ uuid, status: 'committed' }).first();
      return record ? toStateFile(record) : null;
    };


    interface ReadStateFilesOptions {
        skipReverts?: boolean;
    }


    export const readAllStateFiles = async (cwd: string = process.cwd(),
    options: ReadStateFilesOptions = {}): Promise<StateFile[] | null> => {
        const stateDir = getStateDirectory(cwd);
        try {
            await fs.access(stateDir);
        } catch {
            return null; // State directory does not exist, so not initialized
        }

        const db = getDb(cwd);
        const records = await db.query().from('transactions').where({ status: 'committed' }).all();
        
        if (!records) return [];
        
        let validResults = records.map(toStateFile);

        if (options.skipReverts) {
            const revertedUuids = new Set<string>();
            validResults.forEach(sf => {
                if (isRevertTransaction(sf)) {
                    const revertedUuid = getRevertedTransactionUuid(sf);
                    if (revertedUuid) {
                        revertedUuids.add(revertedUuid);
                    }
                }
            });

            validResults = validResults.filter(sf => 
                !isRevertTransaction(sf) && !revertedUuids.has(sf.uuid)
            );
        }

        // Sort transactions by date, most recent first
        validResults.sort(sortByDateDesc);

        return validResults;
    }


    export const findLatestStateFile = async (cwd: string = process.cwd(),
    options: ReadStateFilesOptions = {}): Promise<StateFile | null> => {
        const allFiles = await readAllStateFiles(cwd, options);
        return allFiles?.[0] ?? null;
    };


    export const findStateFileByIdentifier = async (cwd: string, identifier:
    string, options: ReadStateFilesOptions = {}): Promise<StateFile | null> => {
        if (isUUID(identifier)) {
            // When fetching by UUID, we always return it if committed, regardless of whether it's a revert or not.
            const db = getDb(cwd);
            const record = await db.query().from('transactions').where({ uuid: identifier, status: 'committed' }).first();
            return record ? toStateFile(record) : null;
        }
        
        if (/^-?\d+$/.test(identifier)) {
            const index = Math.abs(parseInt(identifier, 10));
            if (isNaN(index) || index <= 0) {
                return null;
            }

            const transactions = await readAllStateFiles(cwd, options);
            if (transactions && transactions.length >= index) {
                return transactions[index - 1] ?? null;
            }
            return null;
        }

        return null;
    };
  src/core/transaction.ts: >
    import { type Config, type ParsedLLMResponse, type StateFile, type
    FileSnapshot, type FileOperation, normalizeGitCommitMsg } from
    'relaycode-core';

    import { logger, getErrorMessage } from '../utils/logger';

    import { getErrorCount, executeShellCommand } from '../utils/shell';

    import { deleteFile, readFileContent, removeEmptyParentDirectories,
    renameFile, writeFileContent } from '../utils/fs';

    import path from 'path';

    import chalk from 'chalk';

    import { applyOperations as applyOperationsCore, calculateLineChanges as
    calculateLineChangesCore } from 'relaycode-core';


    import { commitState, deletePendingState, hasBeenProcessed,
    updatePendingState, writePendingState } from './state';

    import { createConfirmationHandler } from '../utils/prompt';

    import { requestApprovalWithNotification, notifyFailure, notifySuccess,
    notifyPatchDetected, notifyRollbackFailure } from '../utils/notifier';


    type Prompter = (question: string) => Promise<boolean>;


    type ProcessPatchOptions = {
        prompter?: Prompter;
        cwd?: string;
        notifyOnStart?: boolean;
        yes?: boolean;
        skipIndividualApproval?: boolean;
    };


    const pendingTransactions = new Map<string, StateFile>();


    export const createSnapshot = async (filePaths: string[], cwd: string =
    process.cwd()): Promise<FileSnapshot> => {
      const snapshot: FileSnapshot = {};
      await Promise.all(
        filePaths.map(async (filePath) => {
          snapshot[filePath] = await readFileContent(filePath, cwd);
        })
      );
      return snapshot;
    };


    /**
     * Applies a series of file operations to the filesystem and returns the new in-memory file states.
     * This function processes operations sequentially, applying patches (like diffs) against the evolving
     * state of files, and performing filesystem actions (write, delete, rename) along the way.
     * @param operations The file operations to apply.
     * @param originalFiles The initial state of the files.
     * @param cwd The working directory.
     * @returns A map representing the final state of all affected files.
     */
    export const applyOperations = async (  
      operations: FileOperation[],
      originalFiles: Map<string, string | null>,
      cwd: string = process.cwd()
    ): Promise<Map<string, string | null>> => {
      // Step 1: Calculate all new file states in-memory. This is now parallelized inside relaycode-core.
      const result = await applyOperationsCore(operations, originalFiles);

      if (!result.success) {
        throw new Error(`Failed to calculate state changes: ${result.error}`);
      }

      const { newFileStates } = result;

      // Step 2: Apply physical changes to the filesystem.
      // To correctly handle renames, we process rename operations first.
      const renameOps = operations.filter((op): op is Extract<FileOperation, {type: 'rename'}> => op.type === 'rename');
      for (const op of renameOps) {
        await renameFile(op.from, op.to, cwd);
      }

      // Step 3: Apply writes and deletes, which can be done in parallel.
      const fsPromises: Promise<void>[] = [];
      const allPaths = new Set([...originalFiles.keys(), ...newFileStates.keys()]);
      const renamedFromPaths = new Set(renameOps.map(op => op.from));

      for (const path of allPaths) {
        if (renamedFromPaths.has(path)) continue; // This path was a source of a rename, it's already handled.

        const oldContent = originalFiles.get(path);
        const newContent = newFileStates.get(path);
        if (oldContent !== newContent) {
            // Use `== null` to check for both null and undefined.
            // If newContent is missing from the map, it's treated as a deletion.
            if (newContent == null) {
                fsPromises.push(deleteFile(path, cwd));
            } else {
                fsPromises.push(writeFileContent(path, newContent, cwd));
            }
        }
      }
      await Promise.all(fsPromises);

      return newFileStates;
    };


    export const restoreSnapshot = async (snapshot: FileSnapshot, cwd: string =
    process.cwd()): Promise<void> => {
      const projectRoot = path.resolve(cwd);
      const entries = Object.entries(snapshot);
      const directoriesToClean = new Set<string>();
      const restoreErrors: { path: string, error: unknown }[] = [];

      // Attempt to restore all files in parallel, collecting errors.
      await Promise.all(entries.map(async ([filePath, content]) => {
          const fullPath = path.resolve(cwd, filePath);
          try {
            if (content === null) {
              // If the file didn't exist in the snapshot, make sure it doesn't exist after restore.
              await deleteFile(filePath, cwd);
              directoriesToClean.add(path.dirname(fullPath));
            } else {
              // Create directory structure if needed and write the original content back.
              await writeFileContent(filePath, content, cwd);
            }
          } catch (error) {
            restoreErrors.push({ path: filePath, error });
          }
      }));
      
      // After all files are processed, clean up empty directories
      // Sort directories by depth (deepest first) to clean up nested empty dirs properly
      const sortedDirs = Array.from(directoriesToClean)
        .sort((a, b) => b.split(path.sep).length - a.split(path.sep).length);
      
      // Process each directory that had files deleted
      for (const dir of sortedDirs) {
        await removeEmptyParentDirectories(dir, projectRoot);
      }

      if (restoreErrors.length > 0) {
        const errorSummary = restoreErrors
          .map(e => `  - ${e.path}: ${getErrorMessage(e.error)}`)
          .join('\n');
        throw new Error(`Rollback failed for ${restoreErrors.length} file(s):\n${errorSummary}`);
      }
    };


    const logCompletionSummary = (
        uuid: string,
        startTime: number,
        operations: FileOperation[]
    ) => {
        const duration = performance.now() - startTime;

        logger.log(chalk.bold('\nSummary:'));
        logger.log(`Applied ${chalk.cyan(operations.length)} file operation(s) successfully.`);
        logger.log(`Total time from start to commit: ${chalk.gray(`${duration.toFixed(2)}ms`)}`);
        logger.success(`‚úÖ Transaction ${chalk.gray(uuid)} committed successfully!`);
    };


    const rollbackTransaction = async (cwd: string, uuid: string, snapshot:
    FileSnapshot, reason: string, enableNotifications: boolean = true, isError:
    boolean = true): Promise<void> => {
        // Validate UUID to prevent undefined.yaml errors
        if (!uuid || typeof uuid !== 'string' || !uuid.match(/^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$/)) {
            logger.error(`Fatal: Invalid UUID provided for rollback: ${uuid}`);
            return;
        }
        
        if (isError) {
            logger.warn(`Rolling back changes: ${reason}`);
        }

        let rollbackSuccessful = false;
        try {
            await restoreSnapshot(snapshot, cwd);
            logger.success('  - Files restored to original state.');
            rollbackSuccessful = true;
        } catch (error) {
            logger.error(`Fatal: Rollback failed: ${getErrorMessage(error)}`);
            notifyRollbackFailure(uuid, enableNotifications);
            // Do not rethrow; we're already in a final error handling state.
        } finally {
            try {
                await deletePendingState(cwd, uuid);
                pendingTransactions.delete(uuid);
                logger.info(`‚Ü©Ô∏è Transaction ${chalk.gray(uuid)} rolled back.`);
                if (isError && rollbackSuccessful) {
                    notifyFailure(uuid, enableNotifications);
                }
            } catch (cleanupError) {
                logger.error(`Fatal: Could not clean up pending state for ${chalk.gray(uuid)}: ${getErrorMessage(cleanupError)}`);
            }
        }
    };


    type ApprovalOptions = {
        config: Config;
        cwd: string;
        getConfirmation: Prompter;
        skipIndividualApproval?: boolean;
    }


    const handleApproval = async ({ config, cwd, getConfirmation,
    skipIndividualApproval }: ApprovalOptions): Promise<boolean> => {
        const finalErrorCount = await getErrorCount(config.patch.linter, cwd);
        logger.log(`  - Final linter error count: ${finalErrorCount > 0 ? chalk.red(finalErrorCount) : chalk.green(finalErrorCount)}`);
        
        const getManualApproval = async (reason: string): Promise<boolean> => {
            logger.warn(reason);
            
            const notificationResult = await requestApprovalWithNotification(config.projectId, config.core.enableNotifications);

            if (notificationResult === 'approved') {
                logger.info('Approved via notification.');
                return true;
            }
            if (notificationResult === 'rejected') {
                logger.info('Rejected via notification.');
                return false;
            }

            if (notificationResult === 'timeout') {
                logger.info('Notification timed out or was dismissed. Please use the terminal to respond.');
            }

            return await getConfirmation('Changes applied. Do you want to approve and commit them? (y/N)');
        };

        // Skip individual approval if in bulk mode
        if (skipIndividualApproval) {
            logger.info('  - Skipping individual approval for bulk processing.');
            return true; // Auto-approve for bulk processing
        }
        
        if (config.patch.approvalMode === 'manual') {
            return await getManualApproval('Manual approval mode is enabled.');
        }
        // auto mode
        const canAutoApprove = finalErrorCount <= config.patch.approvalOnErrorCount;
        if (canAutoApprove) {
            logger.success('  - Changes automatically approved based on your configuration.');
            return true;
        }
        return await getManualApproval(`Manual approval required: Linter found ${finalErrorCount} error(s) (threshold is ${config.patch.approvalOnErrorCount}).`);
    };


    const _processPatch = async (config: Config, parsedResponse:
    ParsedLLMResponse, options?: ProcessPatchOptions): Promise<void> => {
        const cwd = options?.cwd || process.cwd();
        const getConfirmation = createConfirmationHandler({ yes: options?.yes }, options?.prompter);
        const { control, operations, reasoning } = parsedResponse;
        const { uuid, projectId } = control;
        const startTime = performance.now();

        // 1. Validation
        if (projectId !== config.projectId) {
            logger.warn(`Skipping patch: projectId mismatch (expected '${chalk.cyan(config.projectId)}', got '${chalk.cyan(projectId)}').`);
            return;
        }
        if (await hasBeenProcessed(cwd, uuid)) {
            logger.info(`Skipping patch: uuid '${chalk.gray(uuid)}' has already been processed.`);
            return;
        }

        const { minFileChanges, maxFileChanges } = config.patch;
        const operationCount = operations.length;
        if (minFileChanges > 0 && operationCount < minFileChanges) {
            logger.warn(`Skipping patch: Not enough file changes (expected at least ${minFileChanges}, got ${operationCount}).`);
            return;
        }
        if (maxFileChanges && operationCount > maxFileChanges) {
            logger.warn(`Skipping patch: Too many file changes (expected at most ${maxFileChanges}, got ${operationCount}).`);
            return;
        }

        // Notify if coming from watch mode, now that we know it's a new patch.
        if (options?.notifyOnStart) {
            notifyPatchDetected(config.projectId, config.core.enableNotifications);
            logger.success(`Valid patch detected for project '${chalk.cyan(config.projectId)}'. Processing...`);
        }

        // 2. Pre-flight checks
        if (config.patch.preCommand) {
            logger.log(`  - Running pre-command: ${chalk.magenta(config.patch.preCommand)}`);
            const { exitCode, stderr } = await executeShellCommand(config.patch.preCommand, cwd);
            if (exitCode !== 0) {
                logger.error(`Pre-command failed with exit code ${chalk.red(exitCode)}, aborting transaction.`);
                if (stderr) logger.error(`Stderr: ${stderr}`);
                return;
            }
        }

        logger.info(`üöÄ Starting transaction for patch ${chalk.gray(uuid)}...`);
        logger.log(`${chalk.bold('Reasoning:')}\n  ${reasoning.join('\n  ')}`);

        const affectedFilePaths = operations.reduce<string[]>((acc, op) => {
            if (op.type === 'rename') {
                acc.push(op.from, op.to);
            } else {
                acc.push(op.path);
            }
            return acc;
        }, []);
        const snapshot = await createSnapshot(affectedFilePaths, cwd);
        
        const stateFile: StateFile = {
            uuid,
            projectId,
            createdAt: new Date().toISOString(),
            gitCommitMsg: control.gitCommitMsg,
            promptSummary: control.promptSummary,
            reasoning,
            operations,
            snapshot,
            approved: false,
        };

        try {
            await writePendingState(cwd, stateFile);
            logger.success('  - Staged changes to .pending.yml file.');

            const originalFiles = new Map<string, string | null>();
            affectedFilePaths.forEach(p => originalFiles.set(p, snapshot[p] ?? null));

            // Apply changes
            logger.log('  - Applying file operations...');
            const newFileStates = await applyOperations(operations, originalFiles, cwd);
            logger.success('  - File operations complete.');

            const opStats = operations.map(op => {
                const stats = calculateLineChangesCore(op, originalFiles, newFileStates);
                if (op.type === 'write') {
                    logger.success(`‚úî Written: ${chalk.cyan(op.path)} (${chalk.green(`+${stats.added}`)}, ${chalk.red(`-${stats.removed}`)})`);
                } else if (op.type === 'delete') {
                    logger.success(`‚úî Deleted: ${chalk.cyan(op.path)}`);
                } else if (op.type === 'rename') {
                    logger.success(`‚úî Renamed: ${chalk.cyan(op.from)} -> ${chalk.cyan(op.to)}`);
                }
                return stats;
            });

            // Run post-command
            if (config.patch.postCommand) {
                logger.log(`  - Running post-command: ${chalk.magenta(config.patch.postCommand)}`);
                const postResult = await executeShellCommand(config.patch.postCommand, cwd);
                if (postResult.exitCode !== 0) {
                    logger.error(`Post-command failed with exit code ${chalk.red(postResult.exitCode)}.`);
                    if (postResult.stderr) logger.error(`Stderr: ${postResult.stderr}`);
                    throw new Error('Post-command failed, forcing rollback.');
                }
            }

            // Log summary before asking for approval
            const checksDuration = performance.now() - startTime;
            const totalAdded = opStats.reduce((sum, s) => sum + s.added, 0);
            const totalRemoved = opStats.reduce((sum, s) => sum + s.removed, 0);
            const totalDifference = opStats.reduce((sum, s) => sum + s.difference, 0);

            logger.log(chalk.bold('\nPre-flight summary:'));
            logger.success(`Lines changed: ${chalk.green(`+${totalAdded}`)}, ${chalk.red(`-${totalRemoved}`)} (${chalk.yellow(`${totalDifference} total`)})`);
            logger.log(`Checks completed in ${chalk.gray(`${checksDuration.toFixed(2)}ms`)}`);

            // Store transaction as pending for bulk approval
            stateFile.linesAdded = totalAdded;
            stateFile.linesRemoved = totalRemoved;
            stateFile.linesDifference = totalDifference;
            await updatePendingState(cwd, stateFile);
            pendingTransactions.set(uuid, stateFile);
            
            const pendingCount = pendingTransactions.size;
            logger.info(`Transaction ${chalk.gray(uuid)} is pending approval.`);
            logger.info(`üìã You have ${chalk.cyan(pendingCount)} pending transaction(s) waiting for approval.`);
            logger.info(`Run 'relaycode approve-all' to approve all pending transactions.`);
            
            // Only ask for individual approval if not in bulk mode
            if (!options?.skipIndividualApproval) {
                const isApproved = await handleApproval({ 
                    config, 
                    cwd, 
                    getConfirmation,
                    skipIndividualApproval: false 
                });

                if (isApproved) {
                    stateFile.approved = true;
                    await updatePendingState(cwd, stateFile);
                    await commitState(cwd, uuid);
                    logCompletionSummary(uuid, startTime, operations);
                    notifySuccess(uuid, config.core.enableNotifications);
                    await handleAutoGitBranch(config, stateFile, cwd);
                    pendingTransactions.delete(uuid);
                } else {
                    logger.warn('Operation cancelled by user. Rolling back changes...');
                    await rollbackTransaction(cwd, uuid, snapshot, 'User cancellation', config.core.enableNotifications, false);
                    pendingTransactions.delete(uuid);
                }
            }
        } catch (error) {
            const reason = getErrorMessage(error);
            await rollbackTransaction(cwd, uuid, snapshot, reason, config.core.enableNotifications, true);
        }
    };


    /**
     * Processes a patch transaction. This function acts as a locking wrapper around the core
     * patch processing logic (`_processPatch`) to ensure that only one transaction is
     * processed at a time for a given working directory. This prevents race conditions
     * with the file-based database.
     * @param config The application configuration.
     * @param parsedResponse The parsed response from the LLM.
     * @param options Options for processing the patch.
     */
    export const processPatch = async (config: Config, parsedResponse:
    ParsedLLMResponse, options?: ProcessPatchOptions): Promise<void> => {
        await _processPatch(config, parsedResponse, options);
    };


    export const getPendingTransactionCount = (_cwd: string = process.cwd()):
    number => {
        return pendingTransactions.size;
    };


    export const approveAllPendingTransactions = async (config: Config, cwd:
    string = process.cwd()): Promise<void> => {
        const pending = Array.from(pendingTransactions.values());
        if (pending.length === 0) {
            logger.info('No pending transactions to approve.');
            return;
        }

        logger.info(`Approving ${pending.length} pending transactions...`);
        logger.info(`üìã Processing ${pending.length} transaction(s) for bulk approval...`);
        
        for (const stateFile of pending) {
            try {
                stateFile.approved = true;
                await updatePendingState(cwd, stateFile);
                await commitState(cwd, stateFile.uuid);
                logger.success(`‚úÖ Transaction ${chalk.gray(stateFile.uuid)} committed successfully!`);
                await handleAutoGitBranch(config, stateFile, cwd);
                pendingTransactions.delete(stateFile.uuid);
            } catch (error) {
                logger.error(`Failed to commit transaction ${stateFile.uuid}: ${getErrorMessage(error)}`);
            }
        }
        
        const successCount = pending.filter(stateFile => 
            pendingTransactions.has(stateFile.uuid) === false
        ).length;
        
        logger.success(`‚úÖ Bulk approval completed: ${successCount}/${pending.length} transaction(s) approved successfully.`);
        
        notifySuccess('bulk-approval', config.core.enableNotifications);
    };


    export const processPatchesBulk = async (config: Config, parsedResponses:
    ParsedLLMResponse[], options?: ProcessPatchOptions): Promise<void> => {
        const getConfirmation = createConfirmationHandler({ yes: options?.yes }, options?.prompter);
        
        // Filter out invalid patches
        const validPatches = parsedResponses.filter((response): response is ParsedLLMResponse => {
            if (response.control.projectId !== config.projectId) {
                logger.debug(`Ignoring patch for different project (expected '${config.projectId}', got '${response.control.projectId}').`);
                return false;
            }
            return true;
        });

        if (validPatches.length === 0) {
            logger.info('No valid patches to process.');
            return;
        }

        logger.info(`Processing ${validPatches.length} patches in bulk mode...`);

        // Process all patches sequentially but with bulk approval
        for (let i = 0; i < validPatches.length; i++) {
            const parsedResponse = validPatches[i]!;
            logger.info(`Processing patch ${i + 1}/${validPatches.length} (${parsedResponse.control.uuid})`);
            
            // For bulk processing, we want to skip individual approvals
            // and handle approval at the end
            const bulkOptions = {
                ...options,
                // Skip individual approval for bulk processing
                skipIndividualApproval: true,
            };
            
            await processPatch(config, parsedResponse, bulkOptions);
        }

        // Ask for bulk approval at the end
        const bulkApproved = await getConfirmation(`Processed ${validPatches.length} patches. Do you want to approve and commit all changes? (y/N)`);
        
        if (bulkApproved) {
            logger.success('All patches approved and committed successfully.');
        } else {
            logger.warn('Bulk approval rejected. Individual patches may need to be processed separately.');
        }
    };


    const handleAutoGitBranch = async (config: Config, stateFile: StateFile,
    cwd: string): Promise<void> => {
        if (!config.git.autoGitBranch) return;

        let branchNameSegment = '';
        if (config.git.gitBranchTemplate === 'gitCommitMsg' && stateFile.gitCommitMsg) {
            branchNameSegment = normalizeGitCommitMsg(stateFile.gitCommitMsg) ?? '';
        } else {
            branchNameSegment = stateFile.uuid;
        }

        const sanitizedSegment = branchNameSegment
            .trim()
            .toLowerCase()
            .replace(/[^\w\s-]/g, '') // Remove all non-word, non-space, non-hyphen chars
            .replace(/[\s_]+/g, '-') // Replace spaces and underscores with a single hyphen
            .replace(/-+/g, '-') // Collapse consecutive hyphens
            .replace(/^-|-$/g, '') // Trim leading/trailing hyphens
            .slice(0, 70); // Truncate

        if (sanitizedSegment) {
            const branchName = `${config.git.gitBranchPrefix}${sanitizedSegment}`;
            logger.info(`Creating and switching to new git branch: ${chalk.magenta(branchName)}`);
            const command = `git checkout -b "${branchName}"`;
            const result = await executeShellCommand(command, cwd);
            if (result.exitCode === 0) {
                logger.success(`Successfully created and switched to branch '${chalk.magenta(branchName)}'.`);
            } else {
                // Exit code 128 from `git checkout -b` often means the branch already exists.
                if (result.exitCode === 128 && result.stderr.includes('already exists')) {
                    logger.warn(`Could not create branch '${chalk.magenta(branchName)}' because it already exists.`);
                } else {
                    logger.warn(`Could not create git branch '${chalk.magenta(branchName)}'.`);
                }
                logger.debug(`'${command}' failed with: ${result.stderr}`);
            }
        } else {
            logger.warn('Could not generate a branch name segment from commit message or UUID. Skipping git branch creation.');
        }
    };
approved: false
linesAdded: null
linesRemoved: null
linesDifference: null
gitCommittedAt: null
status: undone
id: 4
