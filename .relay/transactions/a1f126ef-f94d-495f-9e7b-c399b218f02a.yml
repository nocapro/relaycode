uuid: a1f126ef-f94d-495f-9e7b-c399b218f02a
projectId: relaycode
createdAt: '2025-09-04T16:00:36.463Z'
linesAdded: 108
linesRemoved: 53
gitCommitMsg: 'feat: parallelize multi-file operations for performance'
promptSummary: >-
  The user requested to implement parallel and multi-thread processing to
  improve performance of multi-file operations, specifically within
  `relaycode-core`.
reasoning:
  - >-
    gm Anton, let's get this thing cooking with some parallel processing.
    Sequential is for boomers. We're going full multi-core on these file ops to
    make it fly.
  - >-
    I'll refactor `relaycode-core` to handle patch calculations in parallel for
    different files. Then I'll update the main CLI logic to leverage that and
    write files to disk in parallel too. This should make applying big changes
    way faster.
  - '### 1. Parallelize Patch Calculations in `relaycode-core`'
  - >-
    First, I'm diving into `relaycode-core` to refactor the `applyOperations`
    function. The old way was a simple loop, one op at a time. Lame. The new
    hotness will process renames first (they're tricky), then group all other
    changes by file and process each file's changes in parallel using
    `Promise.all`. This is where the magic happens.
  - '### 2. Parallelize Filesystem Operations'
  - >-
    Now that the core can figure out the final state of all files in parallel,
    let's update the transaction logic to write those changes to the disk
    concurrently. Instead of applying and writing one file change at a time,
    we'll calculate all final file contents first, then blast them out to the
    filesystem in a parallel `Promise.all`. Speed up all the things!
  - >-
    There, now we're processing file changes with the power of modern CPUs.
    Should be way more performant for chonky updates.
operations:
  - type: write
    path: packages/relaycode-core/src/patch.ts
    content: >-
      --- packages/relaycode-core/src/patch.ts

      +++ packages/relaycode-core/src/patch.ts

      @@ -1,5 +1,5 @@
       import type { FileOperation } from './types';
      -import { applyStandardDiff, applySearchReplace } from 'apply-multi-diff';

      +import { applyStandardDiff, applySearchReplace } from 'apply-multi-diff';
       
       const patchStrategies = {
         'standard-diff': async (p: { originalContent: string; diffContent: string; }) => {
      @@ -17,70 +17,115 @@
           | { success: true; newFileStates: Map<string, string | null> }
           | { success: false; error: string };
       
      +const applyFileOperations = async (

      +    filePath: string,

      +    ops: (FileOperation & { type: 'write' | 'delete' })[],

      +    initialContent: string | null

      +): Promise<{ success: true, content: string | null } | { success: false,
      error: string }> => {

      +    let currentContent: string | null = initialContent;

      +

      +    for (const op of ops) {

      +        if (op.type === 'delete') {

      +            if (currentContent === null) {

      +                return { success: false, error: `Cannot delete
      non-existent file: ${filePath}` };

      +            }

      +            currentContent = null;

      +            continue;

      +        }

      +

      +        // It must be 'write'

      +        if (op.patchStrategy === 'replace') {

      +            currentContent = op.content;

      +        } else {

      +            const isNewFile = currentContent === null;

      +            if (isNewFile && op.patchStrategy === 'search-replace') {

      +                return { success: false, error: `Cannot use
      'search-replace' on a new file: ${filePath}` };

      +            }

      +

      +            try {

      +                const diffParams = {

      +                    originalContent: currentContent ?? '',

      +                    diffContent: op.content,

      +                };

      +                

      +                const patcher = patchStrategies[op.patchStrategy as keyof
      typeof patchStrategies];

      +                if (!patcher) {

      +                    return { success: false, error: `Unknown patch
      strategy: '${op.patchStrategy}'` };

      +                }

      +                

      +                const result = await patcher(diffParams);

      +                if (result.success) {

      +                    if (typeof result.content !== 'string') {

      +                        return { success: false, error: `Patch for
      ${filePath} succeeded but returned no content.` };

      +                    }

      +                    currentContent = result.content;

      +                } else {

      +                    return { success: false, error: `Patch failed for
      ${filePath}: ${result.error}` };

      +                }

      +            } catch (e) {

      +                const message = e instanceof Error ? e.message :
      String(e);

      +                return { success: false, error: `Error applying patch for
      ${filePath} with strategy '${op.patchStrategy}': ${message}` };

      +            }

      +        }

      +    }

      +    return { success: true, content: currentContent };

      +};

      +
       export const applyOperations = async (
           operations: FileOperation[],
           originalFiles: Map<string, string | null>
       ): Promise<ApplyOperationsResult> => {
           const fileStates = new Map<string, string | null>(originalFiles);
       
      -    for (const op of operations) {

      -        if (op.type === 'delete') {

      -            if (!fileStates.has(op.path) || fileStates.get(op.path) ===
      null) {

      -                return { success: false, error: `Cannot delete
      non-existent file: ${op.path}` };

      -            }

      -            fileStates.set(op.path, null);

      -            continue;

      -        }

      -        if (op.type === 'rename') {

      -            const content = fileStates.get(op.from);

      -            if (content === undefined) {

      -                return { success: false, error: `Cannot rename
      non-existent or untracked file: ${op.from}` };

      -            }

      -            fileStates.set(op.from, null);

      -            fileStates.set(op.to, content);

      -            continue;

      +    // Step 1: Separate renames and handle them sequentially first.

      +    const renameOps = operations.filter((op): op is
      Extract<FileOperation, { type: 'rename' }> => op.type === 'rename');

      +    const otherOps = operations.filter((op): op is Extract<FileOperation,
      { type: 'write' | 'delete' }> => op.type !== 'rename');

      +

      +    const pathMapping = new Map<string, string>(); // from -> to

      +

      +    for (const op of renameOps) {

      +        const content = fileStates.get(op.from);

      +        if (content === undefined) {

      +            return { success: false, error: `Cannot rename non-existent
      or untracked file: ${op.from}` };
               }
      -

      -        let finalContent: string;

      -        const currentContent = fileStates.get(op.path) ?? null;

      -

      -        if (op.patchStrategy === 'replace') {

      -            finalContent = op.content;

      -        } else {

      -            if (currentContent === null && op.patchStrategy ===
      'search-replace') {

      -                return { success: false, error: `Cannot use
      'search-replace' on a new file: ${op.path}` };

      -            }

      -

      -            try {

      -                const diffParams = {

      -                    originalContent: currentContent ?? '',

      -                    diffContent: op.content,

      -                };

      -                

      -                const patcher = patchStrategies[op.patchStrategy as keyof
      typeof patchStrategies];

      -                if (!patcher) {

      -                    return { success: false, error: `Unknown patch
      strategy: '${op.patchStrategy}'` };

      -                }

      -                

      -                const result = await patcher(diffParams);

      -                if (result.success) {

      -                    if (typeof result.content !== 'string') {

      -                        return { success: false, error: `Patch for
      ${op.path} succeeded but returned no content.` };

      -                    }

      -                    finalContent = result.content;

      -                } else {

      -                    return { success: false, error: `Patch failed for
      ${op.path}: ${result.error}` };

      -                }

      -            } catch (e) {

      -                const message = e instanceof Error ? e.message :
      String(e);

      -                return { success: false, error: `Error applying patch for
      ${op.path} with strategy '${op.patchStrategy}': ${message}` };

      -            }

      +        fileStates.set(op.from, null);

      +        fileStates.set(op.to, content);

      +

      +        for (const [from, to] of pathMapping.entries()) {

      +            if (to === op.from) pathMapping.set(from, op.to);
               }
      -        fileStates.set(op.path, finalContent);

      -    }

      -

      -    return { success: true, newFileStates: fileStates };

      +        pathMapping.set(op.from, op.to);

      +    }

      +

      +    // Step 2: Remap paths in other operations based on the renames.

      +    const remappedOps = otherOps.map(op => {

      +        const newPath = pathMapping.get(op.path);

      +        return newPath ? { ...op, path: newPath } : op;

      +    });

      +

      +    // Step 3: Group operations by file path.

      +    const opsByFile = new Map<string, (FileOperation & { type: 'write' |
      'delete' })[]>();

      +    for (const op of remappedOps) {

      +        if (!opsByFile.has(op.path)) opsByFile.set(op.path, []);

      +        opsByFile.get(op.path)!.push(op);

      +    }

      +

      +    // Step 4: Apply operations for each file in parallel.

      +    const promises: Promise<void>[] = [];

      +    let firstError: { error: string } | null = null;

      +

      +    for (const [filePath, fileOps] of opsByFile.entries()) {

      +        promises.push((async () => {

      +            const initialContent = fileStates.get(filePath) ?? null;

      +            const result = await applyFileOperations(filePath, fileOps,
      initialContent);

      +            if (firstError) return;

      +            

      +            if (result.success) fileStates.set(filePath, result.content);

      +            else if (!firstError) firstError = { error: result.error };

      +        })());

      +    }

      +

      +    await Promise.all(promises);

      +

      +    if (firstError) return { success: false, error: firstError.error };

      +    return { success: true, newFileStates: fileStates };
       };
       
       const calculateLcsLength = (a: string[], b: string[]): number => {
    patchStrategy: new-unified
  - type: write
    path: src/core/transaction.ts
    content: >-
      --- src/core/transaction.ts

      +++ src/core/transaction.ts

      @@ -32,38 +32,34 @@
         operations: FileOperation[],
         originalFiles: Map<string, string | null>,
         cwd: string = process.cwd()
       ): Promise<Map<string, string | null>> => {
      -  const fileStates = new Map<string, string | null>(originalFiles);

      +  // Step 1: Calculate all new file states in-memory. This is now
      parallelized inside relaycode-core.

      +  const result = await applyOperationsCore(operations, originalFiles);
       
      -  for (const op of operations) {

      -    // First, calculate the next state in memory using the core function.

      -    const singleOpResult = await applyOperationsCore([op], fileStates);

      -    if (!singleOpResult.success) {

      -      const opPath = op.type === 'rename' ? op.from : op.path;

      -      throw new Error(`Failed to calculate state change for operation on
      '${opPath}': ${singleOpResult.error}`);

      +  if (!result.success) {

      +    throw new Error(`Failed to calculate state changes:
      ${result.error}`);

      +  }

      +

      +  const { newFileStates } = result;

      +

      +  // Step 2: Apply physical changes to the filesystem.

      +  // To correctly handle renames, we process rename operations first.

      +  const renameOps = operations.filter((op): op is Extract<FileOperation,
      {type: 'rename'}> => op.type === 'rename');

      +  for (const op of renameOps) {

      +    await renameFile(op.from, op.to, cwd);

      +  }

      +

      +  // Step 3: Apply writes and deletes, which can be done in parallel.

      +  const fsPromises: Promise<void>[] = [];

      +  const allPaths = new Set([...originalFiles.keys(),
      ...newFileStates.keys()]);

      +  const renamedFromPaths = new Set(renameOps.map(op => op.from));

      +

      +  for (const path of allPaths) {

      +    if (renamedFromPaths.has(path)) continue; // This path was a source
      of a rename, it's already handled.

      +

      +    const oldContent = originalFiles.get(path);

      +    const newContent = newFileStates.get(path);

      +    if (oldContent !== newContent) {

      +        if (newContent === null) fsPromises.push(deleteFile(path, cwd));

      +        else fsPromises.push(writeFileContent(path, newContent, cwd));
           }
      -

      -    // Then, apply the corresponding physical change to the filesystem.

      -    if (op.type === 'delete') {

      -      await deleteFile(op.path, cwd);

      -    } else if (op.type === 'rename') {

      -      await renameFile(op.from, op.to, cwd);

      -    } else if (op.type === 'write') {

      -      const newContent = singleOpResult.newFileStates.get(op.path);

      -      if (typeof newContent === 'string') {

      -        await writeFileContent(op.path, newContent, cwd);

      -      }

      -    }

      -    

      -    // Finally, update the in-memory state for the next iteration.

      -    singleOpResult.newFileStates.forEach((content, path) => {

      -      fileStates.set(path, content);

      -    });
         }
      -  return fileStates;

      +  await Promise.all(fsPromises);

      +

      +  return newFileStates;
       };
       
       export const restoreSnapshot = async (snapshot: FileSnapshot, cwd: string = process.cwd()): Promise<void> => {
    patchStrategy: new-unified
snapshot:
  packages/relaycode-core/src/patch.ts: |-
    import type { FileOperation } from './types';
    import { applyStandardDiff, applySearchReplace } from 'apply-multi-diff';

    const patchStrategies = {
      'standard-diff': async (p: { originalContent: string; diffContent: string; }) => {
        const result = applyStandardDiff(p.originalContent, p.diffContent);
        if (result.success) return { success: true, content: result.content };
        return { success: false, error: result.error.message };
      },
      'search-replace': async (p: { originalContent: string; diffContent: string; }) => {
        const result = applySearchReplace(p.originalContent, p.diffContent);
        if (result.success) return { success: true, content: result.content };
        return { success: false, error: result.error.message };
      },
    };

    export type ApplyOperationsResult = 
        | { success: true; newFileStates: Map<string, string | null> }
        | { success: false; error: string };

    export const applyOperations = async (
        operations: FileOperation[],
        originalFiles: Map<string, string | null>
    ): Promise<ApplyOperationsResult> => {
        const fileStates = new Map<string, string | null>(originalFiles);

        for (const op of operations) {
            if (op.type === 'delete') {
                if (!fileStates.has(op.path) || fileStates.get(op.path) === null) {
                    return { success: false, error: `Cannot delete non-existent file: ${op.path}` };
                }
                fileStates.set(op.path, null);
                continue;
            }
            if (op.type === 'rename') {
                const content = fileStates.get(op.from);
                if (content === undefined) {
                    return { success: false, error: `Cannot rename non-existent or untracked file: ${op.from}` };
                }
                fileStates.set(op.from, null);
                fileStates.set(op.to, content);
                continue;
            }

            let finalContent: string;
            const currentContent = fileStates.get(op.path) ?? null;

            if (op.patchStrategy === 'replace') {
                finalContent = op.content;
            } else {
                if (currentContent === null && op.patchStrategy === 'search-replace') {
                    return { success: false, error: `Cannot use 'search-replace' on a new file: ${op.path}` };
                }

                try {
                    const diffParams = {
                        originalContent: currentContent ?? '',
                        diffContent: op.content,
                    };
                    
                    const patcher = patchStrategies[op.patchStrategy as keyof typeof patchStrategies];
                    if (!patcher) {
                        return { success: false, error: `Unknown patch strategy: '${op.patchStrategy}'` };
                    }
                    
                    const result = await patcher(diffParams);
                    if (result.success) {
                        if (typeof result.content !== 'string') {
                            return { success: false, error: `Patch for ${op.path} succeeded but returned no content.` };
                        }
                        finalContent = result.content;
                    } else {
                        return { success: false, error: `Patch failed for ${op.path}: ${result.error}` };
                    }
                } catch (e) {
                    const message = e instanceof Error ? e.message : String(e);
                    return { success: false, error: `Error applying patch for ${op.path} with strategy '${op.patchStrategy}': ${message}` };
                }
            }
            fileStates.set(op.path, finalContent);
        }

        return { success: true, newFileStates: fileStates };
    };

    const calculateLcsLength = (a: string[], b: string[]): number => {
        let s1 = a;
        let s2 = b;
        if (s1.length < s2.length) {
            [s1, s2] = [s2, s1];
        }
        const m = s1.length;
        const n = s2.length;
        
        const dp = Array(n + 1).fill(0);

        for (let i = 1; i <= m; i++) {
            let prev = 0;
            for (let j = 1; j <= n; j++) {
                const temp = dp[j];
                if (s1[i - 1] === s2[j - 1]) {
                    dp[j] = prev + 1;
                } else {
                    dp[j] = Math.max(dp[j], dp[j - 1]);
                }
                prev = temp;
            }
        }
        return dp[n];
    };

    export const calculateLineChanges = (
        op: FileOperation,
        originalFiles: Map<string, string | null>,
        newFiles: Map<string, string | null>
    ): { added: number; removed: number; difference: number } => {
        if (op.type === 'rename') {
            return { added: 0, removed: 0, difference: 0 };
        }
        const oldContent = originalFiles.get(op.path) ?? null;

        if (op.type === 'delete') {
            const oldLines = oldContent ? oldContent.split('\n') : [];
            return { added: 0, removed: oldLines.length, difference: oldLines.length };
        }
        
        const newContent = newFiles.get(op.path) ?? null;

        if (oldContent === newContent) return { added: 0, removed: 0, difference: 0 };

        const oldLines = oldContent?.split('\n') ?? [];
        const newLines = newContent?.split('\n') ?? [];

        if (oldContent === null || oldContent === '') {
            return { added: newLines.length, removed: 0, difference: newLines.length };
        }
        if (newContent === null || newContent === '') {
            return { added: 0, removed: oldLines.length, difference: oldLines.length };
        }
        
        const lcsLength = calculateLcsLength(oldLines, newLines);
        const added = newLines.length - lcsLength;
        const removed = oldLines.length - lcsLength;
        return { added, removed, difference: added + removed };
    };
  src/core/transaction.ts: >
    import { Config, ParsedLLMResponse, StateFile, FileSnapshot, FileOperation }
    from 'relaycode-core';

    import { logger, getErrorMessage } from '../utils/logger';

    import { getErrorCount, executeShellCommand } from '../utils/shell';

    import { deleteFile, readFileContent, removeEmptyParentDirectories,
    renameFile, writeFileContent } from '../utils/fs';

    import path from 'path';

    import chalk from 'chalk';

    import { applyOperations as applyOperationsCore, calculateLineChanges as
    calculateLineChangesCore } from 'relaycode-core';


    import { commitState, deletePendingState, hasBeenProcessed,
    updatePendingState, writePendingState } from './state';

    import { createConfirmationHandler } from '../utils/prompt';

    import { requestApprovalWithNotification, notifyFailure, notifySuccess,
    notifyPatchDetected, notifyRollbackFailure } from '../utils/notifier';


    type Prompter = (question: string) => Promise<boolean>;


    type ProcessPatchOptions = {
        prompter?: Prompter;
        cwd?: string;
        notifyOnStart?: boolean;
        yes?: boolean;
    };


    export const createSnapshot = async (filePaths: string[], cwd: string =
    process.cwd()): Promise<FileSnapshot> => {
      const snapshot: FileSnapshot = {};
      await Promise.all(
        filePaths.map(async (filePath) => {
          snapshot[filePath] = await readFileContent(filePath, cwd);
        })
      );
      return snapshot;
    };


    /**
     * Applies a series of file operations to the filesystem and returns the new in-memory file states.
     * This function processes operations sequentially, applying patches (like diffs) against the evolving
     * state of files, and performing filesystem actions (write, delete, rename) along the way.
     * @param operations The file operations to apply.
     * @param originalFiles The initial state of the files.
     * @param cwd The working directory.
     * @returns A map representing the final state of all affected files.
     */
    export const applyOperations = async (  
      operations: FileOperation[],
      originalFiles: Map<string, string | null>,
      cwd: string = process.cwd()
    ): Promise<Map<string, string | null>> => {
      const fileStates = new Map<string, string | null>(originalFiles);

      for (const op of operations) {
        // First, calculate the next state in memory using the core function.
        const singleOpResult = await applyOperationsCore([op], fileStates);
        if (!singleOpResult.success) {
          const opPath = op.type === 'rename' ? op.from : op.path;
          throw new Error(`Failed to calculate state change for operation on '${opPath}': ${singleOpResult.error}`);
        }

        // Then, apply the corresponding physical change to the filesystem.
        if (op.type === 'delete') {
          await deleteFile(op.path, cwd);
        } else if (op.type === 'rename') {
          await renameFile(op.from, op.to, cwd);
        } else if (op.type === 'write') {
          const newContent = singleOpResult.newFileStates.get(op.path);
          if (typeof newContent === 'string') {
            await writeFileContent(op.path, newContent, cwd);
          }
        }
        
        // Finally, update the in-memory state for the next iteration.
        singleOpResult.newFileStates.forEach((content, path) => {
          fileStates.set(path, content);
        });
      }
      return fileStates;
    };


    export const restoreSnapshot = async (snapshot: FileSnapshot, cwd: string =
    process.cwd()): Promise<void> => {
      const projectRoot = path.resolve(cwd);
      const entries = Object.entries(snapshot);
      const directoriesToClean = new Set<string>();
      const restoreErrors: { path: string, error: unknown }[] = [];

      // Attempt to restore all files in parallel, collecting errors.
      await Promise.all(entries.map(async ([filePath, content]) => {
          const fullPath = path.resolve(cwd, filePath);
          try {
            if (content === null) {
              // If the file didn't exist in the snapshot, make sure it doesn't exist after restore.
              await deleteFile(filePath, cwd);
              directoriesToClean.add(path.dirname(fullPath));
            } else {
              // Create directory structure if needed and write the original content back.
              await writeFileContent(filePath, content, cwd);
            }
          } catch (error) {
            restoreErrors.push({ path: filePath, error });
          }
      }));
      
      // After all files are processed, clean up empty directories
      // Sort directories by depth (deepest first) to clean up nested empty dirs properly
      const sortedDirs = Array.from(directoriesToClean)
        .sort((a, b) => b.split(path.sep).length - a.split(path.sep).length);
      
      // Process each directory that had files deleted
      for (const dir of sortedDirs) {
        await removeEmptyParentDirectories(dir, projectRoot);
      }

      if (restoreErrors.length > 0) {
        const errorSummary = restoreErrors
          .map(e => `  - ${e.path}: ${getErrorMessage(e.error)}`)
          .join('\n');
        throw new Error(`Rollback failed for ${restoreErrors.length} file(s):\n${errorSummary}`);
      }
    };


    const logCompletionSummary = (
        uuid: string,
        startTime: number,
        operations: FileOperation[]
    ) => {
        const duration = performance.now() - startTime;

        logger.log(chalk.bold('\nSummary:'));
        logger.log(`Applied ${chalk.cyan(operations.length)} file operation(s) successfully.`);
        logger.log(`Total time from start to commit: ${chalk.gray(`${duration.toFixed(2)}ms`)}`);
        logger.success(`✅ Transaction ${chalk.gray(uuid)} committed successfully!`);
    };


    const rollbackTransaction = async (cwd: string, uuid: string, snapshot:
    FileSnapshot, reason: string, enableNotifications: boolean = true, isError:
    boolean = true): Promise<void> => {
        if (isError) {
            logger.warn(`Rolling back changes: ${reason}`);
        }

        let rollbackSuccessful = false;
        try {
            await restoreSnapshot(snapshot, cwd);
            logger.success('  - Files restored to original state.');
            rollbackSuccessful = true;
        } catch (error) {
            logger.error(`Fatal: Rollback failed: ${getErrorMessage(error)}`);
            notifyRollbackFailure(uuid, enableNotifications);
            // Do not rethrow; we're already in a final error handling state.
        } finally {
            try {
                await deletePendingState(cwd, uuid);
                logger.info(`↩️ Transaction ${chalk.gray(uuid)} rolled back.`);
                if (isError && rollbackSuccessful) {
                    notifyFailure(uuid, enableNotifications);
                }
            } catch (cleanupError) {
                logger.error(`Fatal: Could not clean up pending state for ${chalk.gray(uuid)}: ${getErrorMessage(cleanupError)}`);
            }
        }
    };


    type ApprovalOptions = {
        config: Config;
        cwd: string;
        getConfirmation: Prompter;
    }


    const handleApproval = async ({ config, cwd, getConfirmation }:
    ApprovalOptions): Promise<boolean> => {
        const finalErrorCount = await getErrorCount(config.patch.linter, cwd);
        logger.log(`  - Final linter error count: ${finalErrorCount > 0 ? chalk.red(finalErrorCount) : chalk.green(finalErrorCount)}`);
        
        const getManualApproval = async (reason: string): Promise<boolean> => {
            logger.warn(reason);
            
            const notificationResult = await requestApprovalWithNotification(config.projectId, config.core.enableNotifications);

            if (notificationResult === 'approved') {
                logger.info('Approved via notification.');
                return true;
            }
            if (notificationResult === 'rejected') {
                logger.info('Rejected via notification.');
                return false;
            }

            if (notificationResult === 'timeout') {
                logger.info('Notification timed out or was dismissed. Please use the terminal to respond.');
            }

            return await getConfirmation('Changes applied. Do you want to approve and commit them? (y/N)');
        };

        if (config.patch.approvalMode === 'manual') {
            return await getManualApproval('Manual approval mode is enabled.');
        }
        // auto mode
        const canAutoApprove = finalErrorCount <= config.patch.approvalOnErrorCount;
        if (canAutoApprove) {
            logger.success('  - Changes automatically approved based on your configuration.');
            return true;
        }
        return await getManualApproval(`Manual approval required: Linter found ${finalErrorCount} error(s) (threshold is ${config.patch.approvalOnErrorCount}).`);
    };


    export const processPatch = async (config: Config, parsedResponse:
    ParsedLLMResponse, options?: ProcessPatchOptions): Promise<void> => {
        const cwd = options?.cwd || process.cwd();
        const getConfirmation = createConfirmationHandler({ yes: options?.yes }, options?.prompter);
        const { control, operations, reasoning } = parsedResponse;
        const { uuid, projectId } = control;
        const startTime = performance.now();

        // 1. Validation
        if (projectId !== config.projectId) {
            logger.warn(`Skipping patch: projectId mismatch (expected '${chalk.cyan(config.projectId)}', got '${chalk.cyan(projectId)}').`);
            return;
        }
        if (await hasBeenProcessed(cwd, uuid)) {
            logger.info(`Skipping patch: uuid '${chalk.gray(uuid)}' has already been processed.`);
            return;
        }

        const { minFileChanges, maxFileChanges } = config.patch;
        const operationCount = operations.length;
        if (minFileChanges > 0 && operationCount < minFileChanges) {
            logger.warn(`Skipping patch: Not enough file changes (expected at least ${minFileChanges}, got ${operationCount}).`);
            return;
        }
        if (maxFileChanges && operationCount > maxFileChanges) {
            logger.warn(`Skipping patch: Too many file changes (expected at most ${maxFileChanges}, got ${operationCount}).`);
            return;
        }

        // Notify if coming from watch mode, now that we know it's a new patch.
        if (options?.notifyOnStart) {
            notifyPatchDetected(config.projectId, config.core.enableNotifications);
            logger.success(`Valid patch detected for project '${chalk.cyan(config.projectId)}'. Processing...`);
        }

        // 2. Pre-flight checks
        if (config.patch.preCommand) {
            logger.log(`  - Running pre-command: ${chalk.magenta(config.patch.preCommand)}`);
            const { exitCode, stderr } = await executeShellCommand(config.patch.preCommand, cwd);
            if (exitCode !== 0) {
                logger.error(`Pre-command failed with exit code ${chalk.red(exitCode)}, aborting transaction.`);
                if (stderr) logger.error(`Stderr: ${stderr}`);
                return;
            }
        }

        logger.info(`🚀 Starting transaction for patch ${chalk.gray(uuid)}...`);
        logger.log(`${chalk.bold('Reasoning:')}\n  ${reasoning.join('\n  ')}`);

        const affectedFilePaths = operations.reduce<string[]>((acc, op) => {
            if (op.type === 'rename') {
                acc.push(op.from, op.to);
            } else {
                acc.push(op.path);
            }
            return acc;
        }, []);
        const snapshot = await createSnapshot(affectedFilePaths, cwd);
        
        const stateFile: StateFile = {
            uuid,
            projectId,
            createdAt: new Date().toISOString(),
            gitCommitMsg: control.gitCommitMsg,
            promptSummary: control.promptSummary,
            reasoning,
            operations,
            snapshot,
            approved: false,
        };

        try {
            await writePendingState(cwd, stateFile);
            logger.success('  - Staged changes to .pending.yml file.');

            const originalFiles = new Map<string, string | null>();
            affectedFilePaths.forEach(p => originalFiles.set(p, snapshot[p] ?? null));

            // Apply changes
            logger.log('  - Applying file operations...');
            const newFileStates = await applyOperations(operations, originalFiles, cwd);
            logger.success('  - File operations complete.');

            const opStats = operations.map(op => {
                const stats = calculateLineChangesCore(op, originalFiles, newFileStates);
                if (op.type === 'write') {
                    logger.success(`✔ Written: ${chalk.cyan(op.path)} (${chalk.green(`+${stats.added}`)}, ${chalk.red(`-${stats.removed}`)})`);
                } else if (op.type === 'delete') {
                    logger.success(`✔ Deleted: ${chalk.cyan(op.path)}`);
                } else if (op.type === 'rename') {
                    logger.success(`✔ Renamed: ${chalk.cyan(op.from)} -> ${chalk.cyan(op.to)}`);
                }
                return stats;
            });

            // Run post-command
            if (config.patch.postCommand) {
                logger.log(`  - Running post-command: ${chalk.magenta(config.patch.postCommand)}`);
                const postResult = await executeShellCommand(config.patch.postCommand, cwd);
                if (postResult.exitCode !== 0) {
                    logger.error(`Post-command failed with exit code ${chalk.red(postResult.exitCode)}.`);
                    if (postResult.stderr) logger.error(`Stderr: ${postResult.stderr}`);
                    throw new Error('Post-command failed, forcing rollback.');
                }
            }

            // Log summary before asking for approval
            const checksDuration = performance.now() - startTime;
            const totalAdded = opStats.reduce((sum, s) => sum + s.added, 0);
            const totalRemoved = opStats.reduce((sum, s) => sum + s.removed, 0);
            const totalDifference = opStats.reduce((sum, s) => sum + s.difference, 0);

            logger.log(chalk.bold('\nPre-flight summary:'));
            logger.success(`Lines changed: ${chalk.green(`+${totalAdded}`)}, ${chalk.red(`-${totalRemoved}`)} (${chalk.yellow(`${totalDifference} total`)})`);
            logger.log(`Checks completed in ${chalk.gray(`${checksDuration.toFixed(2)}ms`)}`);

            const isApproved = await handleApproval({ config, cwd, getConfirmation });

            if (isApproved) {
                stateFile.approved = true;
                stateFile.linesAdded = totalAdded;
                stateFile.linesRemoved = totalRemoved;
                stateFile.linesDifference = totalDifference;
                await updatePendingState(cwd, stateFile); // Update state with approval and stats before commit
                await commitState(cwd, uuid);
                logCompletionSummary(uuid, startTime, operations);
                notifySuccess(uuid, config.core.enableNotifications);
                await handleAutoGitBranch(config, stateFile, cwd);
            } else {
                logger.warn('Operation cancelled by user. Rolling back changes...');
                await rollbackTransaction(cwd, uuid, snapshot, 'User cancellation', config.core.enableNotifications, false);
            }
        } catch (error) {
            const reason = getErrorMessage(error);
            await rollbackTransaction(cwd, uuid, snapshot, reason, config.core.enableNotifications, true);
        }
    };


    const handleAutoGitBranch = async (config: Config, stateFile: StateFile,
    cwd: string): Promise<void> => {
        if (!config.git.autoGitBranch) return;

        let branchNameSegment = '';
        if (config.git.gitBranchTemplate === 'gitCommitMsg' && stateFile.gitCommitMsg) {
            branchNameSegment = stateFile.gitCommitMsg;
        } else {
            branchNameSegment = stateFile.uuid;
        }

        const sanitizedSegment = branchNameSegment
            .trim()
            .toLowerCase()
            .replace(/[^\w\s-]/g, '') // Remove all non-word, non-space, non-hyphen chars
            .replace(/[\s_]+/g, '-') // Replace spaces and underscores with a single hyphen
            .replace(/-+/g, '-') // Collapse consecutive hyphens
            .replace(/^-|-$/g, '') // Trim leading/trailing hyphens
            .slice(0, 70); // Truncate

        if (sanitizedSegment) {
            const branchName = `${config.git.gitBranchPrefix}${sanitizedSegment}`;
            logger.info(`Creating and switching to new git branch: ${chalk.magenta(branchName)}`);
            const command = `git checkout -b "${branchName}"`;
            const result = await executeShellCommand(command, cwd);
            if (result.exitCode === 0) {
                logger.success(`Successfully created and switched to branch '${chalk.magenta(branchName)}'.`);
            } else {
                // Exit code 128 from `git checkout -b` often means the branch already exists.
                if (result.exitCode === 128 && result.stderr.includes('already exists')) {
                    logger.warn(`Could not create branch '${chalk.magenta(branchName)}' because it already exists.`);
                } else {
                    logger.warn(`Could not create git branch '${chalk.magenta(branchName)}'.`);
                }
                logger.debug(`'${command}' failed with: ${result.stderr}`);
            }
        } else {
            logger.warn('Could not generate a branch name segment from commit message or UUID. Skipping git branch creation.');
        }
    };
approved: true
