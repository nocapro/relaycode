uuid: 442e3b2b-4ec9-4702-861c-5bbd841261d2
projectId: relaycode
createdAt: '2025-09-03T03:49:36.276Z'
linesAdded: 3
linesRemoved: 3
gitCommitMsg: 'fix(konro): relax konro.object constraint to support array types'
promptSummary: >-
  Fix TypeScript errors in src/core/db.ts related to konro.object generic
  constraints.
reasoning:
  - got it, switching to `new-unified`. hacker style.
operations:
  - type: write
    path: packages/konro/src/schema.ts
    content: >-
      --- packages/konro/src/schema.ts

      +++ packages/konro/src/schema.ts

      @@ -141,10 +141,10 @@
       /** A managed timestamp set when a record is created and updated. */
       export const updatedAt = (): ColumnDefinition<Date> => createColumn<Date>('date', { _konro_sub_type: 'updatedAt', default: () => new Date() }, new Date());
       /** A managed, nullable timestamp for soft-deleting records. */
       export const deletedAt = (): ColumnDefinition<Date | null> => createColumn<Date | null>('date', { _konro_sub_type: 'deletedAt', default: null }, null);
       /** A column for storing arbitrary JSON objects, with a generic for type safety. */
      -export function object<T extends Record<string, unknown>>(options: {
      optional: true; default?: T | null | (() => T | null) }):
      ColumnDefinition<T | null>;

      -export function object<T extends Record<string, unknown>>(options?: {
      optional?: false; default?: T | (() => T) }): ColumnDefinition<T>;

      -export function object<T extends Record<string, unknown>>(

      +export function object<T extends object>(options: { optional: true;
      default?: T | null | (() => T | null) }): ColumnDefinition<T | null>;

      +export function object<T extends object>(options?: { optional?: false;
      default?: T | (() => T) }): ColumnDefinition<T>;

      +export function object<T extends object>(
       options?: { optional?: boolean; default?: unknown }
       ): ColumnDefinition<T | null> | ColumnDefinition<T> {
         if (options?.optional) {
    patchStrategy: new-unified
snapshot:
  packages/konro/src/schema.ts: "//\r\n// Konro: The Type-Safe, Functional ORM for JSON/YAML\r\n//\r\n// ## Pillar I: The Recipe (Schema Definition)\r\n//\r\n// This file contains the core logic for defining a database schema. It is designed to be\r\n// both the runtime source of truth for validation and the static source of truth for\r\n// TypeScript types. By using phantom types and inference, we can create a fully-typed\r\n// `db` object from a single schema definition object, eliminating the need for manual\r\n// type declarations (`interface User { ... }`) and ensuring they never get out of sync.\r\n//\r\n\r\nimport type {\r\n  KonroSchema,\r\n  ColumnDefinition,\r\n  OneRelationDefinition,\r\n  ManyRelationDefinition,\r\n  AggregationDefinition\r\n} from './types';\r\n\r\n// --- SCHEMA BUILDER FUNCTION ---\r\n\r\n/**\r\n * Defines the structure, types, and relations of your database.\r\n * This is the single source of truth for both runtime validation and static types.\r\n *\r\n * @param schemaDef The schema definition object.\r\n * @returns A processed schema object with inferred types attached.\r\n */\r\nexport const createSchema = <\r\n  const TDef extends {\r\n    tables: Record<string, Record<string, ColumnDefinition<any>>>;\r\n    relations?: (tables: TDef['tables']) => Record<string, Record<string, OneRelationDefinition | ManyRelationDefinition>>;\r\n  }\r\n>(\r\n  schemaDef: TDef\r\n): KonroSchema<TDef['tables'], TDef['relations'] extends (...args: any) => any ? ReturnType<TDef['relations']> : {}> => { // eslint-disable-line\r\n  const relations = schemaDef.relations ? schemaDef.relations(schemaDef.tables) : {};\r\n  return {\r\n    tables: schemaDef.tables,\r\n    relations: relations as any, // Cast to bypass complex conditional type issue\r\n    // Types are applied via the return type annotation, these are just placeholders at runtime.\r\n    types: null as any,\r\n    base: {} as any,\r\n    create: {} as any,\r\n  };\r\n};\r\n\r\n\r\n// --- COLUMN DEFINITION HELPERS ---\r\n\r\nconst createColumn = <T>(dataType: ColumnDefinition<T>['dataType'], options: object | undefined, tsType: T): ColumnDefinition<T> => ({\r\n  _type: 'column',\r\n  dataType,\r\n  options,\r\n  _tsType: tsType,\r\n});\r\n\r\n/** A managed, auto-incrementing integer primary key. This is the default strategy. */\r\nexport const id = () => createColumn<number>('id', { unique: true, _pk_strategy: 'auto-increment' }, 0);\r\n/** A managed, universally unique identifier (UUID) primary key. Stored as a string. */\r\nexport const uuid = () => createColumn<string>('id', { unique: true, _pk_strategy: 'uuid' }, '');\r\n\r\n// A shared base type for options to avoid repetition in overloads.\r\ntype BaseStringOptions = {\r\n  unique?: boolean;\r\n  min?: number;\r\n  max?: number;\r\n  format?: 'email' | 'uuid' | 'url';\r\n};\r\n/** A string column with optional validation. */\r\nexport function string(options: BaseStringOptions & { optional: true; default?: string | null | (() => string | null) }): ColumnDefinition<string | null>;\r\nexport function string(options?: BaseStringOptions & { optional?: false; default?: string | (() => string) }): ColumnDefinition<string>;\r\nexport function string(options?: BaseStringOptions & { optional?: boolean; default?: unknown }): ColumnDefinition<string> | ColumnDefinition<string | null> {\r\n  if (options?.optional) {\r\n    return createColumn<string | null>('string', options, null);\r\n  }\r\n  return createColumn<string>('string', options, '');\r\n}\r\n\r\ntype BaseNumberOptions = {\r\n  unique?: boolean;\r\n  min?: number;\r\n  max?: number;\r\n  type?: 'integer';\r\n};\r\n/** A number column with optional validation. */\r\nexport function number(options: BaseNumberOptions & { optional: true; default?: number | null | (() => number | null) }): ColumnDefinition<number | null>;\r\nexport function number(options?: BaseNumberOptions & { optional?: false; default?: number | (() => number) }): ColumnDefinition<number>;\r\nexport function number(options?: BaseNumberOptions & { optional?: boolean; default?: unknown }): ColumnDefinition<number> | ColumnDefinition<number | null> {\r\n  if (options?.optional) {\r\n    return createColumn<number | null>('number', options, null);\r\n  }\r\n  return createColumn<number>('number', options, 0);\r\n}\r\n\r\n/** A boolean column. */\r\nexport function boolean(options: { optional: true; default?: boolean | null | (() => boolean | null) }): ColumnDefinition<boolean | null>;\r\nexport function boolean(options?: { optional?: false; default?: boolean | (() => boolean) }): ColumnDefinition<boolean>;\r\nexport function boolean(options?: { optional?: boolean; default?: unknown }): ColumnDefinition<boolean> | ColumnDefinition<boolean | null> {\r\n  if (options?.optional) {\r\n    return createColumn<boolean | null>('boolean', options, null);\r\n  }\r\n  return createColumn<boolean>('boolean', options, false);\r\n}\r\n\r\n/** A generic date column. Consider using `createdAt` or `updatedAt` for managed timestamps. */\r\nexport function date(options: { optional: true; default?: Date | null | (() => Date | null) }): ColumnDefinition<Date | null>;\r\nexport function date(options?: { optional?: false; default?: Date | (() => Date) }): ColumnDefinition<Date>;\r\nexport function date(options?: { optional?: boolean; default?: unknown }): ColumnDefinition<Date> | ColumnDefinition<Date | null> {\r\n  if (options?.optional) {\r\n    return createColumn<Date | null>('date', options, null);\r\n  }\r\n  return createColumn<Date>('date', options, new Date());\r\n}\r\n\r\n/** A managed timestamp set when a record is created. */\r\nexport const createdAt = (): ColumnDefinition<Date> => createColumn<Date>('date', { _konro_sub_type: 'createdAt', default: () => new Date() }, new Date());\r\n/** A managed timestamp set when a record is created and updated. */\r\nexport const updatedAt = (): ColumnDefinition<Date> => createColumn<Date>('date', { _konro_sub_type: 'updatedAt', default: () => new Date() }, new Date());\r\n/** A managed, nullable timestamp for soft-deleting records. */\r\nexport const deletedAt = (): ColumnDefinition<Date | null> => createColumn<Date | null>('date', { _konro_sub_type: 'deletedAt', default: null }, null);\r\n/** A column for storing arbitrary JSON objects, with a generic for type safety. */\r\nexport function object<T extends Record<string, unknown>>(options: { optional: true; default?: T | null | (() => T | null) }): ColumnDefinition<T | null>;\r\nexport function object<T extends Record<string, unknown>>(options?: { optional?: false; default?: T | (() => T) }): ColumnDefinition<T>;\r\nexport function object<T extends Record<string, unknown>>(\roptions?: { optional?: boolean; default?: unknown }\n): ColumnDefinition<T | null> | ColumnDefinition<T> {\r\n  if (options?.optional) {\r\n    // The cast here is to satisfy the generic constraint on the implementation.\r\n    // The phantom type will be `T | null`.\r\n    return { _type: 'column', dataType: 'object', options } as ColumnDefinition<T | null>;\r\n  }\r\n  return { _type: 'column', dataType: 'object', options };\r\n}\r\n\r\n\r\n// --- RELATIONSHIP DEFINITION HELPERS ---\r\n\r\n/** Defines a `one-to-one` or `many-to-one` relationship. */\r\nexport const one = <T extends string>(targetTable: T, options: { on: string; references: string; onDelete?: 'CASCADE' | 'SET NULL' }): OneRelationDefinition & { targetTable: T } => ({\r\n  _type: 'relation',\r\n  relationType: 'one',\r\n  targetTable,\r\n  ...options,\r\n});\r\n\r\n/** Defines a `one-to-many` relationship. */\r\nexport const many = <T extends string>(targetTable: T, options: { on: string; references: string; onDelete?: 'CASCADE' | 'SET NULL' }): ManyRelationDefinition & { targetTable: T } => ({\r\n  _type: 'relation',\r\n  relationType: 'many',\r\n  targetTable,\r\n  ...options,\r\n});\r\n\r\n\r\n// --- AGGREGATION DEFINITION HELPERS ---\r\n\r\n/** Aggregation to count records. */\r\nexport const count = (): AggregationDefinition => ({ _type: 'aggregation', aggType: 'count' });\r\n/** Aggregation to sum a numeric column. */\r\nexport const sum = (column: string): AggregationDefinition => ({ _type: 'aggregation', aggType: 'sum', column });\r\n/** Aggregation to average a numeric column. */\r\nexport const avg = (column: string): AggregationDefinition => ({ _type: 'aggregation', aggType: 'avg', column });\r\n/** Aggregation to find the minimum value in a numeric column. */\r\nexport const min = (column: string): AggregationDefinition => ({ _type: 'aggregation', aggType: 'min', column });\r\n/** Aggregation to find the maximum value in a numeric column. */\r\nexport const max = (column: string): AggregationDefinition => ({ _type: 'aggregation', aggType: 'max', column });"
approved: true
