uuid: d895a98d-d55c-449e-b816-ff45e902b28c
projectId: relaycode
createdAt: '2025-09-04T00:08:00.378Z'
linesAdded: 6
linesRemoved: 7
gitCommitMsg: 'fix(core): correct transaction state logic and stabilize e2e tests'
promptSummary: >-
  The user provided a list of failing tests in `test/e2e/transaction.test.ts`
  and asked me to fix them. The failures were related to transaction state
  management (reprocessing failed transactions) and how pre/post commands were
  handled in the test environment.
reasoning:
  - >-
    ayoo, another day another bug to squash. these e2e tests are failing, looks
    like a couple of separate issues. one is some gnarly state management logic,
    the other seems to be some weirdness with how shell commands are running in
    the test env. let's get this sorted.
  - >-
    First, I'm fixing the state management logic. When a transaction fails and
    rolls back, it was being marked as 'undone'. The problem is, the logic to
    check if a transaction has already been processed was treating 'undone' as
    'final', which meant you couldn't retry the same patch. That's no good.
  - >-
    I'm changing `hasBeenProcessed` to only consider `committed` transactions as
    final. Then, I'm updating `writePendingState` to clean up any old `pending`
    *or* `undone` records for the same transaction UUID. This allows a
    failed/cancelled transaction to be re-run from scratch.
  - >-
    Next, for the tests. The `preCommand` and `postCommand` failure tests were
    failing because the commands weren't exiting with an error code as expected.
    It seems like running `bun -e "process.exit(1)"` inside `bun test` is a bit
    funky. I'm swapping that out for the `false` command, which is a classic
    *nix way to get a command that always fails. Another test was already using
    this and passing, so this should make things more reliable.
  - These changes should get the tests passing again. peace out.
operations:
  - type: write
    path: src/core/state.ts
    content: |-
      <<<<<<< SEARCH
        // A transaction has been processed if it exists and is either committed or undone.
        // A pending transaction has not been fully processed.
        return !!record && (record.status === 'committed' || record.status === 'undone');
      =======
        // Only 'committed' transactions are considered final. 'undone' or 'pending' ones can be re-processed.
        return !!record && record.status === 'committed';
      >>>>>>> REPLACE
      <<<<<<< SEARCH
        // First, remove any orphaned pending transaction with the same UUID to prevent unique constraint errors.
        await db.delete('transactions').where({ uuid: state.uuid, status: 'pending' });
      =======
        // First, remove any orphaned pending or undone transaction with the same UUID to prevent unique constraint errors.
        await db.delete('transactions').where((r) => r.uuid === state.uuid && (r.status === 'pending' || r.status === 'undone'));
      >>>>>>> REPLACE
    patchStrategy: multi-search-replace
  - type: write
    path: test/e2e/transaction.test.ts
    content: |-
      --- test/e2e/transaction.test.ts
      +++ test/e2e/transaction.test.ts
      @@ -176,7 +176,7 @@
         it('should abort transaction if preCommand fails', async () => {
           const { uuid } = await runProcessPatch(
             context,
      -      { preCommand: 'bun -e "process.exit(1)"' },
      +      { preCommand: 'false' },
             [{ type: 'edit', path: testFile, content: 'new content' }]
           );
       
      @@ -191,7 +191,7 @@
         it('should automatically roll back if postCommand fails', async () => {
           const { uuid } = await runProcessPatch(
             context,
      -      { postCommand: 'bun -e "process.exit(1)"' },
      +      { postCommand: 'false' },
             [{ type: 'edit', path: testFile, content: 'new content' }]
           );
    patchStrategy: new-unified
snapshot:
  src/core/state.ts: >-
    import { StateFile } from 'relaycode-core';

    import { logger } from '../utils/logger';

    import { getDb, toStateFile, fromStateFile } from './db';

    import { promises as fs } from 'fs';

    import path from 'path';

    import { getStateDirectory } from './config';


    export const isRevertTransaction = (state: StateFile): boolean => {
        return state.reasoning.some(r => r.startsWith('Reverting transaction'));
    }


    export const getRevertedTransactionUuid = (state: StateFile): string | null
    => {
        for (const r of state.reasoning) {
            const match = r.match(/^Reverting transaction ([\w-]+)\./);
            if (match && match[1]) {
                return match[1];
            }
        }
        return null;
    }


    const isUUID = (str: string): boolean => {
      return /^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$/.test(str);
    };


    const sortByDateDesc = (a: { createdAt: string | Date }, b: { createdAt:
    string | Date }) => {
        return new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime();
    };


    export const hasBeenProcessed = async (cwd: string, uuid: string):
    Promise<boolean> => {
      const db = getDb(cwd);
      const record = await db.query().from('transactions').where({ uuid }).first();
      // A transaction has been processed if it exists and is either committed or undone.
      // A pending transaction has not been fully processed.
      return !!record && (record.status === 'committed' || record.status === 'undone');
    };


    export const writePendingState = async (cwd: string, state: StateFile):
    Promise<void> => {
      const db = getDb(cwd);
      // First, remove any orphaned pending transaction with the same UUID to prevent unique constraint errors.
      await db.delete('transactions').where({ uuid: state.uuid, status: 'pending' });

      // Now, insert the new pending transaction.
      const data = { ...fromStateFile(state), status: 'pending' };
      await db.insert('transactions', data as any);
    };


    export const updatePendingState = async (cwd:string, state: StateFile):
    Promise<void> => {
        const db = getDb(cwd);
        const data = fromStateFile(state);
        const updated = await db.update('transactions').set(data as any).where({ uuid: state.uuid, status: 'pending' });
        if (updated.length === 0) {
            logger.warn(`Could not find pending transaction with uuid ${state.uuid} to update.`);
        }
    }


    export const commitState = async (cwd: string, uuid: string): Promise<void>
    => {
      const db = getDb(cwd);
      // Also update status from 'pending' to 'committed'
      const updated = await db.update('transactions').set({ status: 'committed' }).where({ uuid, status: 'pending' });
      if (updated.length === 0) {
          logger.warn(`Could not find pending transaction with uuid ${uuid} to commit.`);
      }
    };


    export const deletePendingState = async (cwd: string, uuid: string):
    Promise<void> => {
      const db = getDb(cwd);
      // In case of rollback, we mark it as 'undone' instead of deleting.
      const updated = await db.update('transactions').set({ status: 'undone' }).where({ uuid, status: 'pending' });
      if (updated.length === 0) {
        logger.debug(`Could not find pending transaction with uuid ${uuid} to mark as undone. It might have been committed or already undone.`);
      }
    };


    export const readStateFile = async (cwd: string, uuid: string):
    Promise<StateFile | null> => {
      const db = getDb(cwd);
      const record = await db.query().from('transactions').where({ uuid, status: 'committed' }).first();
      return record ? toStateFile(record) : null;
    };


    interface ReadStateFilesOptions {
        skipReverts?: boolean;
    }


    export const readAllStateFiles = async (cwd: string = process.cwd(),
    options: ReadStateFilesOptions = {}): Promise<StateFile[] | null> => {
        const dbDir = path.join(getStateDirectory(cwd), 'db');
        try {
            await fs.access(dbDir);
        } catch {
            return null; // DB directory does not exist, so not initialized
        }

        const db = getDb(cwd);
        let records = await db.query().from('transactions').where({ status: 'committed' }).all();
        
        if (!records) return [];
        
        let validResults = records.map(toStateFile);

        if (options.skipReverts) {
            const revertedUuids = new Set<string>();
            validResults.forEach(sf => {
                if (isRevertTransaction(sf)) {
                    const revertedUuid = getRevertedTransactionUuid(sf);
                    if (revertedUuid) {
                        revertedUuids.add(revertedUuid);
                    }
                }
            });

            validResults = validResults.filter(sf => 
                !isRevertTransaction(sf) && !revertedUuids.has(sf.uuid)
            );
        }

        // Sort transactions by date, most recent first
        validResults.sort(sortByDateDesc);

        return validResults;
    }


    export const findLatestStateFile = async (cwd: string = process.cwd(),
    options: ReadStateFilesOptions = {}): Promise<StateFile | null> => {
        const allFiles = await readAllStateFiles(cwd, options);
        return allFiles?.[0] ?? null;
    };


    export const findStateFileByIdentifier = async (cwd: string, identifier:
    string, options: ReadStateFilesOptions = {}): Promise<StateFile | null> => {
        if (isUUID(identifier)) {
            // When fetching by UUID, we always return it if committed, regardless of whether it's a revert or not.
            const db = getDb(cwd);
            const record = await db.query().from('transactions').where({ uuid: identifier, status: 'committed' }).first();
            return record ? toStateFile(record) : null;
        }
        
        if (/^-?\d+$/.test(identifier)) {
            const index = Math.abs(parseInt(identifier, 10));
            if (isNaN(index) || index <= 0) {
                return null;
            }

            const transactions = await readAllStateFiles(cwd, options);
            if (transactions && transactions.length >= index) {
                return transactions[index - 1] ?? null;
            }
            return null;
        }

        return null;
    };
  test/e2e/transaction.test.ts: >
    import { describe, it, expect, beforeEach, afterEach } from 'bun:test';

    import { promises as fs } from 'fs';

    import path from 'path';

    import { v4 as uuidv4 } from 'uuid';

    import { setupE2ETest, E2ETestContext, createTestFile, runProcessPatch }
    from '../test.util';

    import { STATE_DIRECTORY_NAME } from '../../src/utils/constants';

    import { readStateFile } from '../../src/core/state';

    import type { StateFile } from 'relaycode-core';


    describe('e2e/transaction', () => {
      let context: E2ETestContext;
      const testFile = 'src/index.ts';
      const originalContent = 'console.log("original");';

      beforeEach(async () => {
        context = await setupE2ETest({ withTsconfig: true });
        await createTestFile(context.testDir.path, testFile, originalContent);
      });

      afterEach(async () => {
        if (context) await context.cleanup();
      });

      it('should apply changes, commit, and store correct state in the database', async () => {
        const newContent = 'console.log("new content");';
        const { uuid } = await runProcessPatch(
          context,
          { linter: '', approvalMode: 'auto' },
          [{ type: 'edit', path: testFile, content: newContent }]
        );
        // Add a small delay to ensure file operations have completed
        await new Promise(resolve => setTimeout(resolve, 100));

        // Check file content
        const finalContent = await fs.readFile(path.join(context.testDir.path, testFile), 'utf-8');
        expect(finalContent).toBe(newContent);

        const stateData = await readStateFile(context.testDir.path, uuid);

        expect(stateData).not.toBeNull();
        if (!stateData) return; // type guard

        expect(stateData.uuid).toBe(uuid);
        expect(stateData.approved).toBe(true);
        expect(stateData.operations).toHaveLength(1);
        expect(stateData.operations[0].path).toBe(testFile);
        expect(stateData.snapshot[testFile]).toBe(originalContent);
        expect(stateData.reasoning).toBeDefined();
      });

      it('should rollback changes when manually disapproved', async () => {
        const { uuid } = await runProcessPatch(
          context,
          { approvalMode: 'manual' },
          [{ type: 'edit', path: testFile, content: 'console.log("I will be rolled back");' }],
          { prompter: async () => false }
        );

        const finalContent = await fs.readFile(path.join(context.testDir.path, testFile), 'utf-8');
        expect(finalContent).toBe(originalContent);

        const stateData = await readStateFile(context.testDir.path, uuid);
        expect(stateData).toBeNull();
      });

      it('should fallback to shell execution for non-tsc linters and require approval on failure', async () => {
        await runProcessPatch(
          context,
          // 'false' is a command that always exits with 1. This tests the shell fallback.
          { approvalMode: 'auto', approvalOnErrorCount: 0, linter: 'false' },
          [{ type: 'edit', path: testFile, content: 'any content' }],
          { prompter: async () => false } // Disapprove manually
        );

        const finalContent = await fs.readFile(path.join(context.testDir.path, testFile), 'utf-8');
        expect(finalContent).toBe(originalContent); // Should be rolled back
      });

      it('should require manual approval if linter errors exceed approvalOnErrorCount', async () => {
        await runProcessPatch(
          context,
          { approvalMode: 'auto', approvalOnErrorCount: 0, linter: 'bun tsc -b --noEmit' },
          [{ type: 'edit', path: testFile, content: 'const x: string = 123;' }],
          { prompter: async () => false }
        );

        const finalContent = await fs.readFile(path.join(context.testDir.path, testFile), 'utf-8');
        expect(finalContent).toBe(originalContent);
      });

      it('should skip linter if command is empty and auto-approve', async () => {
        const badContent = 'const x: string = 123;'; // Would fail linter, but it's skipped

        await runProcessPatch(
          context,
          { linter: '' },
          [{ type: 'edit', path: testFile, content: badContent }]
        );

        const finalContent = await fs.readFile(path.join(context.testDir.path, testFile), 'utf-8');
        expect(finalContent).toBe(badContent);
      });

      it('should ignore patch with already processed UUID', async () => {
        const uuid = uuidv4();

        // 1. Process and commit a patch
        await runProcessPatch(context, {}, [{ type: 'edit', path: testFile, content: "first change" }], { responseOverrides: { uuid } });

        // 2. Try to process another patch with the same UUID - this will create a new response with the same UUID.
        // The `processPatch` logic should see the existing state file and ignore it.
        await runProcessPatch(context, {}, [{ type: 'edit', path: testFile, content: "second change" }], { responseOverrides: { uuid } });

        // Content should be from the first change, not the second
        const finalContent = await fs.readFile(path.join(context.testDir.path, testFile), 'utf-8');
        expect(finalContent).toBe("first change");
      });

      it('should create nested directories for new files', async () => {
        const newFilePath = 'src/a/b/c/new-file.ts';
        const newFileContent = 'hello world';

        await runProcessPatch(
          context,
          {},
          [{ type: 'new', path: newFilePath, content: newFileContent }]
        );

        const finalContent = await fs.readFile(path.join(context.testDir.path, newFilePath), 'utf-8');
        expect(finalContent).toBe(newFileContent);
      });

      it('should rollback new file and its new empty parent directory on rejection', async () => {
        const newFilePath = 'src/new/dir/file.ts';

        await runProcessPatch(context, { approvalMode: 'manual' },
          [{ type: 'new', path: newFilePath, content: 'content' }], { prompter: async () => false });

        const fileExists = await fs.access(path.join(context.testDir.path, newFilePath)).then(() => true).catch(() => false);
        expect(fileExists).toBe(false);

        const dirExists = await fs.access(path.join(context.testDir.path, 'src/new/dir')).then(() => true).catch(() => false);
        expect(dirExists).toBe(false);

        const midDirExists = await fs.access(path.join(context.testDir.path, 'src/new')).then(() => true).catch(() => false);
        expect(midDirExists).toBe(false);

        // src directory should still exist as it contained a file before
        const srcDirExists = await fs.access(path.join(context.testDir.path, 'src')).then(() => true).catch(() => false);
        expect(srcDirExists).toBe(true);
      });

      it('should not delete parent directory on rollback if it was not empty beforehand', async () => {
        const existingFilePath = 'src/shared/existing.ts';
        const newFilePath = 'src/shared/new.ts';

        await createTestFile(context.testDir.path, existingFilePath, 'const existing = true;');

        await runProcessPatch(context, { approvalMode: 'manual' },
          [{ type: 'new', path: newFilePath, content: 'const brandNew = true;' }],
          { prompter: async () => false });

        // New file should be gone
        const newFileExists = await fs.access(path.join(context.testDir.path, newFilePath)).then(() => true).catch(() => false);
        expect(newFileExists).toBe(false);

        // Existing file and its directory should remain
        const existingFileExists = await fs.access(path.join(context.testDir.path, existingFilePath)).then(() => true).catch(() => false);
        expect(existingFileExists).toBe(true);

        const sharedDirExists = await fs.access(path.join(context.testDir.path, 'src/shared')).then(() => true).catch(() => false);
        expect(sharedDirExists).toBe(true);
      });

      it('should abort transaction if preCommand fails', async () => {
        const { uuid } = await runProcessPatch(
          context,
          { preCommand: 'bun -e "process.exit(1)"' },
          [{ type: 'edit', path: testFile, content: 'new content' }]
        );

        // File should not have been changed
        const finalContent = await fs.readFile(path.join(context.testDir.path, testFile), 'utf-8');
        expect(finalContent).toBe(originalContent);

        // No state file should have been created
        const stateData = await readStateFile(context.testDir.path, uuid);
        expect(stateData).toBeNull();
      });

      it('should automatically roll back if postCommand fails', async () => {
        const { uuid } = await runProcessPatch(
          context,
          { postCommand: 'bun -e "process.exit(1)"' },
          [{ type: 'edit', path: testFile, content: 'new content' }]
        );

        // File should have been rolled back
        const finalContent = await fs.readFile(path.join(context.testDir.path, testFile), 'utf-8');
        expect(finalContent).toBe(originalContent);

        // No state file should have been committed
        const stateData = await readStateFile(context.testDir.path, uuid);
        expect(stateData).toBeNull();
      });

      it('should ignore patch with non-matching projectId', async () => {
        const { uuid } = await runProcessPatch(
          context,
          { projectId: 'correct-project' },
          [{ type: 'edit', path: testFile, content: 'should not be applied' }],
          { responseOverrides: { projectId: 'wrong-project' } }
        );

        const finalContent = await fs.readFile(path.join(context.testDir.path, testFile), 'utf-8');
        expect(finalContent).toBe(originalContent);

        // No state file should have been committed
        const stateData = await readStateFile(context.testDir.path, uuid);
        expect(stateData).toBeNull();
      });

      it('should correctly apply a file deletion operation', async () => {
        const fileToDelete = 'src/delete-me.ts';
        const originalDeleteContent = 'delete this content';
        await createTestFile(context.testDir.path, fileToDelete, originalDeleteContent);

        const { uuid } = await runProcessPatch(
          context,
          {},
          [{ type: 'delete', path: fileToDelete }]
        );

        const deletedFileExists = await fs.access(path.join(context.testDir.path, fileToDelete)).then(() => true).catch(() => false);
        expect(deletedFileExists).toBe(false);

        const stateData = await readStateFile(context.testDir.path, uuid);
        expect(stateData).not.toBeNull();
      });

      it('should correctly roll back a file deletion operation', async () => {
        const fileToDelete = 'src/delete-me.ts';
        const originalDeleteContent = 'delete this content';
        await createTestFile(context.testDir.path, fileToDelete, originalDeleteContent);

        const { uuid } = await runProcessPatch(
          context, { approvalMode: 'manual' },
          [{ type: 'delete', path: fileToDelete }], { prompter: async () => false }
        );

        const restoredFileExists = await fs.access(path.join(context.testDir.path, fileToDelete)).then(() => true).catch(() => false);
        expect(restoredFileExists).toBe(true);

        // Content should be the same as the original
        const restoredContent = await fs.readFile(path.join(context.testDir.path, fileToDelete), 'utf-8');
        expect(restoredContent).toBe(originalDeleteContent);

        // No state file should have been committed
        const stateData = await readStateFile(context.testDir.path, uuid);
        expect(stateData).toBeNull();
      });

      it('should auto-approve if linter errors are within approvalOnErrorCount', async () => {
        const badContent = 'const x: string = 123;'; // 1 TS error

        const { uuid } = await runProcessPatch(
          context,
          { approvalMode: 'auto', approvalOnErrorCount: 1, linter: 'bun tsc -b --noEmit' },
          [{ type: 'edit', path: testFile, content: badContent }]
        );

        const finalContent = await fs.readFile(path.join(context.testDir.path, testFile), 'utf-8');
        expect(finalContent).toBe(badContent);

        // State file should have been committed
        const stateData = await readStateFile(context.testDir.path, uuid);
        expect(stateData).not.toBeNull();
      });

      it('should overwrite an orphaned pending transaction and allow reprocessing', async () => {
        const uuid = uuidv4();
        const newContent = 'console.log("final content");';

        // Create an orphaned pending transaction by running a patch and not approving it.
        // We'll use a trick: have the prompter throw an error to simulate a crash after the pending state is written.
        try {
          await runProcessPatch(
            context,
            { approvalMode: 'manual' },
            [{ type: 'edit', path: testFile, content: "this won't be applied" }],
            { responseOverrides: { uuid }, prompter: async () => { throw new Error('Simulated crash'); } }
          );
        } catch (e: any) {
          expect(e.message).toBe('Simulated crash');
        }

        await runProcessPatch(
          context,
          {},
          [{ type: 'edit', path: testFile, content: newContent }],
          { responseOverrides: { uuid } }
        );
        const finalContent = await fs.readFile(path.join(context.testDir.path, testFile), 'utf-8');
        expect(finalContent).toBe(newContent);

        // A committed state file should exist
        const stateData = await readStateFile(context.testDir.path, uuid);
        expect(stateData).not.toBeNull();
        if (!stateData) return;
        // The final committed reasoning should be from the second run.
        expect(stateData.operations[0].content).toContain('final content');
      });

      it('should run pre and post commands in the correct order', async () => {
        const preCommandFile = path.join(context.testDir.path, 'pre.txt');
        const postCommandFile = path.join(context.testDir.path, 'post.txt');

        // Use bun to create files as it's more reliable in this environment
        // On Windows, paths in shell commands need to be escaped or use forward slashes
        const preCommand = `bun -e "await Bun.write('${preCommandFile.replace(/\\/g, '/')}', '')"`;
        const postCommand = `bun -e "await Bun.write('${postCommandFile.replace(/\\/g, '/')}', '')"`;

        await runProcessPatch(
          context,
          {
            preCommand,
            postCommand,
          },
          [{ type: 'edit', path: testFile, content: 'new content' }]
        );

        const preExists = await fs.access(preCommandFile).then(() => true).catch(() => false);
        expect(preExists).toBe(true);

        const postExists = await fs.access(postCommandFile).then(() => true).catch(() => false);
        expect(postExists).toBe(true);

        const finalContent = await fs.readFile(path.join(context.testDir.path, testFile), 'utf-8');
        expect(finalContent).toBe('new content');
      });

      it('should create a pending record during transaction and mark as undone on rollback', async () => {
        const uuid = uuidv4();

        // We can't easily check the DB *during* the transaction.
        // Instead, we will check that no committed record exists after rollback.
        // The state transition is pending -> undone.
        // We don't have a way to check for 'undone' records with the current state API,
        // but we can check that it's not 'committed'.

        // Check if the pending file exists during the transaction
        // This part is no longer testable in the same way with an in-process DB.
        // let pendingFileExistedDuringRun = false;

        const prompter = async (): Promise<boolean> => {
          // pendingFileExistedDuringRun = (await getDb(context.testDir.path).query().from('transactions').where({ uuid, status: 'pending' }).first()) != null;
          return false; // Disapprove to trigger rollback
        };

        await runProcessPatch(
          context,
          { approvalMode: 'manual' },
          [{ type: 'edit', path: testFile, content: 'I will be rolled back' }],
          { prompter, responseOverrides: { uuid } }
        );

        // No committed file should exist
        const committedState = await readStateFile(context.testDir.path, uuid);
        expect(committedState).toBeNull();
      });

      it('should fail transaction gracefully if a file is not writable and rollback all changes', async () => {
        const unwritableFile = 'src/unwritable.ts';
        const writableFile = 'src/writable.ts';
        const originalUnwritableContent = 'original unwritable';
        const originalWritableContent = 'original writable';

        await createTestFile(context.testDir.path, unwritableFile, originalUnwritableContent);
        await createTestFile(context.testDir.path, writableFile, originalWritableContent);

        const unwritableFilePath = path.join(context.testDir.path, unwritableFile);

        try {
          await fs.chmod(unwritableFilePath, 0o444); // Make read-only

          const { uuid } = await runProcessPatch(
            context, {},
            [
              { type: 'edit', path: writableFile, content: 'new writable content' },
              { type: 'edit', path: unwritableFile, content: 'new unwritable content' }
            ]
          );

          // Check file states: both should be rolled back to original content.
          const finalWritable = await fs.readFile(path.join(context.testDir.path, writableFile), 'utf-8');
          expect(finalWritable).toBe(originalWritableContent);

          const finalUnwritable = await fs.readFile(path.join(context.testDir.path, unwritableFile), 'utf-8');
          expect(finalUnwritable).toBe(originalUnwritableContent);

          // No state file should have been committed
          const stateData = await readStateFile(context.testDir.path, uuid);
          expect(stateData).toBeNull();
        } finally {
          // Make the file writable again to allow cleanup
          try {
            await fs.chmod(unwritableFilePath, 0o644);
          } catch (err) {
            console.error('Failed to restore file permissions:', err);
          }
        }
      });

      it('should rollback gracefully if creating a file in a non-writable directory fails', async () => {
        const readonlyDir = 'src/readonly-dir';
        const newFilePath = path.join(readonlyDir, 'new-file.ts');
        const readonlyDirPath = path.join(context.testDir.path, readonlyDir);

        await fs.mkdir(readonlyDirPath, { recursive: true });
        await fs.chmod(readonlyDirPath, 0o555); // Read and execute only

        try {
          const { uuid } = await runProcessPatch(
            context,
            {},
            [{ type: 'new', path: newFilePath, content: 'this should not be written' }]
          );

          // Check that the new file was not created
          const newFileExists = await fs.access(path.join(context.testDir.path, newFilePath)).then(() => true).catch(() => false);
          expect(newFileExists).toBe(false);

          // No state file should have been committed
          const stateData = await readStateFile(context.testDir.path, uuid);
          expect(stateData).toBeNull();
        } finally {
          // Restore permissions for cleanup
          try {
            // The directory might have been removed on rollback, so check if it exists first.
            if (await fs.access(readonlyDirPath).then(() => true).catch(() => false)) {
              await fs.chmod(readonlyDirPath, 0o755);
            }
          } catch (err) {
            console.error('Failed to restore directory permissions:', err);
          }
        }
      });

      it('should correctly rollback a complex transaction (modify, delete, create)', async () => {
        // Setup initial files
        const fileToModify = 'src/modify.ts';
        const originalModifyContent = 'export const a = 1;';
        await createTestFile(context.testDir.path, fileToModify, originalModifyContent);

        const fileToDelete = 'src/delete.ts';
        const originalDeleteContent = 'export const b = 2;';
        await createTestFile(context.testDir.path, fileToDelete, originalDeleteContent);

        const newFilePath = 'src/new/component.ts';
        const newFileContent = 'export const c = 3;';

        // Disapprove the transaction
        await runProcessPatch(
          context,
          { approvalMode: 'manual' },
          [
            { type: 'edit', path: fileToModify, content: 'export const a = 100;' },
            { type: 'delete', path: fileToDelete },
            { type: 'new', path: newFilePath, content: newFileContent }
          ], { prompter: async () => false }
        );

        // Verify rollback
        const modifiedFileContent = await fs.readFile(path.join(context.testDir.path, fileToModify), 'utf-8');
        expect(modifiedFileContent).toBe(originalModifyContent);

        const deletedFileExists = await fs.access(path.join(context.testDir.path, fileToDelete)).then(() => true).catch(() => false);
        expect(deletedFileExists).toBe(true);

        const deletedFileContent = await fs.readFile(path.join(context.testDir.path, fileToDelete), 'utf-8');
        expect(deletedFileContent).toBe(originalDeleteContent);

        const newFileExists = await fs.access(path.join(context.testDir.path, newFilePath)).then(() => true).catch(() => false);
        expect(newFileExists).toBe(false);
      });

      it('should correctly apply multiple sequential operations on the same file, including a rename', async () => {
        const originalFilePath = 'src/service.ts';
        const renamedFilePath = 'src/services/main-service.ts';
        const originalServiceContent = `class Service {
        name = "MyService";

        execute() {
            console.log("Executing service");
        }
    }`;
        await createTestFile(context.testDir.path, originalFilePath, originalServiceContent);

        // First, a standard diff to rename a property and add a new one.
        const unifiedDiff = `--- a/${originalFilePath}
    +++ b/${originalFilePath}

    @@ -1,5 +1,6 @@
     class Service {
    -     name = "MyService";

    +    name = "MyAwesomeService";

    +    version = "1.0";

         execute() {
             console.log("Executing service");
        }
    }`;

        // Then, a search-replace to update a method on the *result* of the first patch.
        const searchReplaceDiff = `
    <<<<<<< SEARCH
            console.log("Executing service");
    =======
            console.log(\`Executing service \${this.name} v\${this.version}\`);
    >>>>>>> REPLACE

    `;

        // And finally, rename the file.
        const { uuid } = await runProcessPatch(
          context,
          {},
          [
            { type: 'edit', path: originalFilePath, content: unifiedDiff, strategy: 'new-unified' },
            { type: 'edit', path: originalFilePath, content: searchReplaceDiff, strategy: 'multi-search-replace' },
            { type: 'rename', from: originalFilePath, to: renamedFilePath },
          ]
        );

        // 1. Verify file system state
        const originalFileExists = await fs.access(path.join(context.testDir.path, originalFilePath)).then(() => true).catch(() => false);
        expect(originalFileExists).toBe(false);

        const renamedFileExists = await fs.access(path.join(context.testDir.path, renamedFilePath)).then(() => true).catch(() => false);
        expect(renamedFileExists).toBe(true);

        // 2. Verify final content
        const finalContent = await fs.readFile(path.join(context.testDir.path, renamedFilePath), 'utf-8');
        const expectedContent = `class Service {
        name = "MyAwesomeService";
        version = "1.0";

        execute() {
            console.log(\`Executing service \${this.name} v\${this.version}\`);
        }
    }`;
        expect(finalContent.replace(/\s/g, '')).toBe(expectedContent.replace(/\s/g, ''));

        // 3. Verify snapshot in state file for rollback purposes
        const stateData = await readStateFile(context.testDir.path, uuid);
        expect(stateData).not.toBeNull();
        expect(stateData?.snapshot[originalFilePath]).toBe(originalServiceContent);
        expect(stateData?.snapshot[renamedFilePath]).toBe(null); // It didn't exist at snapshot time
      });
    });
approved: true
